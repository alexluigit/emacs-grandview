#+TITLE: Emacs Grandview
#+AUTHOR: Alex Lu
#+EMAIL: alexluigit@gmail.com
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: showstars

* Overview
:PROPERTIES:
:CUSTOM_ID: h:1AECDD3A-9714-41E1-BA21-8BCAFED96CD3
:END:
** Screenshots
:PROPERTIES:
:CUSTOM_ID: h:E576E55C-B129-42CC-BE83-09221F922E40
:END:

*** File manager
:PROPERTIES:
:CUSTOM_ID: h:1EE04408-E38E-4B45-8CBD-88DA74E2BDB8
:END:
[[https://user-images.githubusercontent.com/16313743/169456875-ed5af1e7-57cd-4203-96e9-9038119721b9.png][https://user-images.githubusercontent.com/16313743/169456875-ed5af1e7-57cd-4203-96e9-9038119721b9.png]]

*** IDE
:PROPERTIES:
:CUSTOM_ID: h:FB80E836-BBA4-426B-8229-C4304DBEED8B
:END:
[[https://user-images.githubusercontent.com/16313743/169660050-b66d09b7-617e-46a0-a2a9-138c570d1336.png][https://user-images.githubusercontent.com/16313743/169660050-b66d09b7-617e-46a0-a2a9-138c570d1336.png]]

*** Org-mode
:PROPERTIES:
:CUSTOM_ID: h:31D50107-120F-4B7C-8E85-A139A712C23F
:END:
[[https://user-images.githubusercontent.com/16313743/169660518-bb1fd05c-089a-41db-830d-43784ae14d6d.png][https://user-images.githubusercontent.com/16313743/169660518-bb1fd05c-089a-41db-830d-43784ae14d6d.png]]

*** Lightning fast startup
:PROPERTIES:
:CUSTOM_ID: h:82AAA786-8F45-4D42-AA97-07EAE86FB26C
:END:
[[https://user-images.githubusercontent.com/16313743/169660620-c5f7bef5-499a-4ea2-8a39-3e0f2801cb24.png][https://user-images.githubusercontent.com/16313743/169660620-c5f7bef5-499a-4ea2-8a39-3e0f2801cb24.png]]

** Introduction
:PROPERTIES:
:CUSTOM_ID: h:4784C101-BDA0-479D-B44D-0709D4B028F3
:END:

*Emacs grandview* is my literate Emacs configuration which has a pretty
straightforward project structure:

+ Early init:              =early-init.el=
+ Init:                    =init.el=
+ User config (optional):  =user.el=
+ Main config file (.org): This file (defaults to =grandview.org=)

*** The early init file (early-init.el)
:PROPERTIES:
:CUSTOM_ID: h:610D1070-5D79-466F-A5A5-7068396F2D41
:END:

It is sometimes necessary to have customizations take effect during Emacs
startup earlier than the normal init file is processed. Such customizations can
be put in the early init file.  This file is loaded before the package system
and GUI is initialized, so in it you can customize variables that affect the
package initialization process, such as =package-enable-at-startup=,
=package-load-list=, and =package-user-dir=.

*** The initialization file (init.el)
:PROPERTIES:
:CUSTOM_ID: h:DF24DB4D-F3B6-47B2-AE76-F5728FF1CFB4
:END:

The main responsibility of my =init.el= is to arrange the tangling procedure of
the =grandview.org= file.

In addition, several custom options were introduced in this file:

+ ~grandview-envs~: Use these environment variables in GUI emacs.
+ ~grandview-cache-dir~: Cache directory for grandview.

You'll see other custom option such as ~grandview-fixed-font~ in the following
sections.

*** User config
:PROPERTIES:
:CUSTOM_ID: h:9102F88E-A57C-48D2-A606-FF01002E4D98
:END:

=user.el= can be the place to put your *grandview* specific configuration or other
arbitrary settings to load before loading =grandview.el=.

Here is a example of =user.el=:

#+begin_src emacs-lisp :tangle no
;; adjust font size
(setq grandview-font-size 150)

;; use this font as fixed font
(setq grandview-fixed-font "Victor Mono")

;; set this theme
(setq grandview-theme 'modus-operandi)

;; use http proxy
(pushnew! grandview-envs
          '("HTTP_PROXY" . "http://localhost:1080")
          '("HTTPS_PROXY" . "http://localhost:1080"))

;; set initial frame opacity
(setq +frame-opacity 80)

;; enable copilot when programming
(add-hook 'prog-mode-hook 'copilot-mode)

;; ... other customizations
#+end_src

*** This =.org= file
:PROPERTIES:
:CUSTOM_ID: h:95B6B174-9877-4DCB-B298-86B3B889A11F
:END:

This file holds *both* source code and documentation of this project. See:
[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]].  Thus, to configure your Emacs using this project, all you
have to do is edit this file, and ~M-x restart-emacs~ to apply the new settings,
nothing else.  If you are new to =org-mode=, check out the video: [[https://www.youtube.com/watch?v=0-brF21ShRk][Org mode Intro]],
or read their documentation: https://orgmode.org/.  Try move the cursor to one
of the headings in this file and press =Tab= to fold / unfold the node would be a
good start.

The elisp source blocks in this file is tangled to a regular =grandview.el= file
which is then evaluated by Emacs.  Sections named *Autoload* are tangled to
separate files upon which corresponding autoloads are generated.

After you modify the contents of code blocks in this file, you may want to apply
these changes immediately, just ~M-x ~restart-emacs~, after restart the old config
is automatically replaced by the newly generated one, and the newly opened emacs
will apply the latest config.  It is the same behavior you would expect with a
regular emacs config which don't follow the literate programming fashion.  A
caveat is that before doing so you'd better have a quick look to check if all
the parentheses are balanced, otherwise emacs won't start correctly.

Thanks to the magical ~org-toggle-comment~ command (binds to =C-c ;= by default),
manage the config becomes easy peasy.  When you find that your code in one or
more sections is problematic and try to debug it, just comment out these
sections then do ~restart-emacs~, all the configuartions in these sections are
ignored (not being tangled at the first place actually).

** Installation
:PROPERTIES:
:CUSTOM_ID: h:B45EA3C7-3DE3-42A1-AAD6-45FC9A5A6FBB
:END:

Make sure to backup your own emacs config before installation.

#+begin_src shell :tangle no
cp -r ~/.emacs.d ~/.emacs.d.bak
#+end_src

*** Dependencies
:PROPERTIES:
:CUSTOM_ID: h:33BF2C72-9505-4C59-877C-8495A625A372
:END:

Here are the dependencies of this project.

|-------------------+-----------------------------+----------|
| Package           | Description                 | Required |
|-------------------+-----------------------------+----------|
| =fd=                | A modern =find=               |          |
| =rg=                | A modern =grep=               |          |
| =git=               | Version control             |          |
| =words=             | English words completion    | optional |
| =noto-fonts-emoji=  | Font for emojis             | optional |
| =Iosveka Nerd Font= | Default font                | optional |
| =font-victor-mono=  | Default fixed pitch font    | optional |
| =ttf-sarasa-gothic= | Default variable pitch font | optional |
|-------------------+-----------------------------+----------|
*** Tangling
:PROPERTIES:
:CUSTOM_ID: h:C5499A98-AF3B-4528-B557-407A18037E93
:END:

Clone the repo and tangle the config.

#+begin_src shell :tangle no
git clone https://www.github.com/alexluigit/emacs-grandview
## move the repo to ~/.config/emacs, which conforms to the XDG spec
mv ~/emacs-grandview ~/.config/emacs/
## or use symlink
# ln -sf ~/Code/emacs-grandview ~/.config/emacs
## or you can put it to ~/.emacs.d, it's an old convention
# mv ~/emacs-grandview ~/.emacs.d

## hooray, enjoy the Emacs-Grandview

emacs

## NOTE: After the first initialization you should be able to start/restart
## Emacs by 'rem' bash command, see the "** Restart Emacs" section below.
#+end_src

** Restart Emacs
:PROPERTIES:
:CUSTOM_ID: h:2DCD6D3B-6759-4E78-AF50-5B23FA77C603
:END:

Although Emacs already provided functionalities like ~unload-feature~ and
~remove-hook~ to eliminate the side effects of certain packages or user
configurations, most of the time it's still easier to reload your Emacs
configurations through a complete restart.  Although emacs comes with the
~restart-emacs~ command, however, when Emacs hangs up, =M-x= or keybindings is not
accessible to us, in this case, a shell script to restart Emacs from terminal
can be very handy.

*** Source
:PROPERTIES:
:CUSTOM_ID: h:BAC15BC3-840C-415A-ABD5-D40AD74853A4
:END:

Here is the source code for the =rem= (acronym for ~restart-emacs~) command.  The
first elisp code block is consumed by the second code block to inject a few
values such as file path into the actual shell script.

You don't need to install this script if you have followed =Installation=
section. This script will be tangled to *~/.local/bin/rem*, so make sure
*~/.local/bin* is in your *PATH*.

#+name: grandview-cache
#+begin_src emacs-lisp :var type="main" :tangle no
(pcase type
  ("home" (file-name-directory user-init-file))
  ("main" (format "%s" grandview-cache-dir))
  ("pkg-repos" (format "%s" package-user-dir)))
#+end_src

#+begin_src bash :tangle "~/.local/bin/rem" :shebang "#!/usr/bin/env bash" :noweb yes
PKG="" REPOs=false RESET=false DEBUG="" BIN="emacs"
INIT_DIR="--init-directory <<grandview-cache(type="home")>>"
[[ $(uname) == "Darwin" ]] && BIN="/Applications/Emacs.app/Contents/MacOS/Emacs"

while getopts "p:Prd" opt; do
  case $opt in
    p) PKG=$OPTARG;;
    P) REPOs=true;;
    r) RESET=true;;
    d) DEBUG=--debug-init;;
  esac
done
shift $((OPTIND -1))

emacs_cmd="$BIN $DEBUG $INIT_DIR >/dev/null 2>&1 & disown"
kill -9 $(pgrep -x '[Ee]macs') 2>/dev/null
[[ -n $PKG ]]  && rm -rf <<grandview-cache(type="pkg-repos")>>/$PKG 2>/dev/null
$RESET && rm -rf '<<grandview-cache(type="main")>>' 2>/dev/null
$REPOs && rm -rf '<<grandview-cache(type="pkg-repos")>>' 2>/dev/null
eval $emacs_cmd
#+end_src

*** Usage
:PROPERTIES:
:CUSTOM_ID: h:0E7E2FDB-8AD8-4BF3-BAD4-2AD1FB43083C
:END:

Here are the available flags of this command.

+ ~-r~: Before restarting, re-tangle this org file.
+ ~-p <NAME>~: Before restarting, delete cache of package *NAME*.
+ ~-P~: Before restarting, delete all package caches.
+ ~-d~: use =--debug-init= flag for the daemon.

* GRANDVIEW CORE
:PROPERTIES:
:CUSTOM_ID: h:FB2572C2-4DDC-44A2-92C0-D8754305B2A7
:END:

This section contains all the *core modules of grandview*.  The modal editing
system (like =vim=) is powered by =meow= (thanks to *@DogLooksGood*!).  All the core
user interface configs such as themes and fonts are also listed below.  Please
*DO NOT* comment this entire section out unless you know exactly what you are
doing.

#+begin_src emacs-lisp
;;; grandview.el --- tangled from grandview.org  -*- lexical-binding: t -*-
;; Generated by the `grandview-tangle' function.
;; Package-Requires: ((emacs "30"))
;; This file is not part of GNU Emacs.

;;; Commentary:
;; Auto generated file, do not edit.

;;; Code:

#+end_src

** Package manager
:PROPERTIES:
:CUSTOM_ID: h:F8A8595A-6466-49D8-902B-3CA74C9B0657
:END:

As the author of =use-package= stated, '=use-package= is *not* a package manager'.
Instead, it's purpose is to allow you to isolate package configuration in your
.emacs file in a way that is both performance-oriented and, well, tidy.

Nonetheless, we still use it together with =package.el= to act as our package
manager, there are several reasons for that:

+ Both of them are built-in to Emacs (we use emacs30).
+ =use-package= is able to adjust the package loading order using ~:after~ keyword.
+ =use-package= now support the ~:vc~ keyword to install package from source.
+ For our use cases, the package configs are maintained out side of =use-package=
  anyway, so I guess it's fine to use them the "wrong" way.

In order to expand its lazy-loading capabilities, here I bring in the
=:after-call= keyword definition from *doom-emacs*.

#+begin_src elisp :tangle no
;; The keyword should be used like this:
(use-package some-package :after-call SYMBOL|LIST)
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'use-package-core
  ;; `use-package' adds syntax highlighting for the `use-package' macro, but
  ;; Emacs 26+ already highlights macros, so it's redundant.
  (font-lock-remove-keywords 'emacs-lisp-mode use-package-font-lock-keywords)

  (push :after-call use-package-deferring-keywords)
  (setq use-package-keywords
        (use-package-list-insert :after-call use-package-keywords :after))

  (defvar grandview--deferred-packages-alist '(t))
  (setq
   use-package-compute-statistics init-file-debug
   use-package-verbose init-file-debug
   use-package-minimum-reported-time (if init-file-debug 0 0.1)
   use-package-expand-minimally (not noninteractive)
   use-package-vc-prefer-newest t
   use-package-always-defer t)

  (defun grandview--log (string &optional label)
    "Log STRING out.
Optional LABEL can be a symbol or string, use GRANDVIEW by default."
    (let* ((label-str (cond ((and label (symbolp label)) (symbol-name label))
                            ((stringp label) label)
                            (t "GRANDVIEW")))
           (label (propertize label-str 'face 'font-lock-builtin-face)))
      (prog1 nil (message "%s" (format "%s: %s" label string)))))

  (defalias 'use-package-normalize/:after-call #'use-package-normalize-symlist)
  (defun use-package-handler/:after-call (name _keyword hooks rest state)
    (if (plist-get state :demand)
        (use-package-process-keywords name rest state)
      (let ((fn (make-symbol (format "grandview--after-call-%s-h" name))))
        (use-package-concat
         `((fset ',fn
                 (lambda (&rest _)
                   (grandview--log (format "package「%s」lazy loaded" ',name))
                   (condition-case e
                       ;; If `default-directory' is a directory that doesn't
                       ;; exist or is unreadable, Emacs throws up file-missing
                       ;; errors, so we set it to a directory we know exists and
                       ;; is readable.
                       (let ((default-directory user-emacs-directory))
                         (require ',name))
                     ((debug error)
                      (message "Failed to load deferred package %s: %s" ',name e)))
                   (when-let (deferral-list (assq ',name grandview--deferred-packages-alist))
                     (dolist (hook (cdr deferral-list))
                       (advice-remove hook #',fn)
                       (remove-hook hook #',fn))
                     (delq! deferral-list grandview--deferred-packages-alist)
                     (unintern ',fn nil)))))
         (let (forms)
           (dolist (hook hooks forms)
             (push (if (string-match-p "-\\(?:functions\\|hook\\)$" (symbol-name hook))
                       `(add-hook ',hook #',fn)
                     `(advice-add #',hook :before #',fn))
                   forms)))
         `((unless (assq ',name grandview--deferred-packages-alist)
             (push '(,name) grandview--deferred-packages-alist))
           (nconc (assq ',name grandview--deferred-packages-alist)
                  '(,@hooks)))
         (use-package-process-keywords name rest state))))))
#+end_src

*** Macros for configuring packages
:PROPERTIES:
:CUSTOM_ID: h:3407EAC6-5A0B-4B67-8237-DAFF12B63F63
:END:

A few handy macros (taken from =doom-emacs=) were defined to be used in elisp code
blocks of this =.org= file, you'll see them appear in this file a couple of times.
These macros are also accessible in =user.el=.

+ =appendq!=: append lists to a symbol.
+ =delq!=: delete an element from a list.
+ =pushnew!=: add items to a list if they aren't there.
+ =prependq!=: prepend lists to somewhere.
+ =defadvice!=: Drop-in replacement for =advice-add=.

#+begin_src lisp :tangle (expand-file-name "grandview-macros.el" grandview-cache-dir)
;;; grandview-macros.el --- handy macros for configuring packages -*- lexical-binding: t -*-

;;; Commentary:

;;; Auto generated by function `grandview-tangle', do not edit.

;;; Code:

(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defmacro delq! (elt list)
  "`delq' ELT from LIST in-place."
  `(setq ,list (delq ,elt ,list)))

(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))

(defmacro prependq! (sym &rest lists)
  "Prepend LISTS to SYM in place."
  `(setq ,sym (append ,@lists ,sym)))

(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.
ARGLIST is as in `defun'.  WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.
\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body)
                   (let ((l ,(pop body))) (if (proper-list-p l) l (list l))))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))

(provide 'grandview-macros)
;;; grandview-macros.el ends here
#+end_src

** Basic editing utilities
:PROPERTIES:
:CUSTOM_ID: h:0EFB6EF1-C52F-4EC8-8257-F3C21300AC0A
:END:

=simple.el= consists of a grab-bag of basic Emacs commands not specifically
related to some major mode or to file-handling.

- Unbind =SPC= in /*messages*/ buffer since we use it as the leader key
- Recenter the screen and highlight the keywords after we call ~next/previous-error~

#+begin_src emacs-lisp
(use-package simple :ensure nil :after meow)

(with-eval-after-load 'simple
  (define-key messages-buffer-mode-map (kbd "SPC") nil)
  (add-hook 'next-error-hook #'recenter)
  (setq next-error-message-highlight t)) ; added in Emacs 28.1
#+end_src

*** Tab for Indentation (indent.el)
:PROPERTIES:
:CUSTOM_ID: h:1EE47211-84CB-4880-8D62-592999C7441D
:END:

I believe tabs, in the sense of inserting the tab character, are best suited for
indentation.  While spaces are superior at precisely aligning text.  However, I
understand that elisp uses its own approach, which I do not want to interfere
with.  Also, Emacs tends to perform alignments by mixing tabs with spaces, which
can actually lead to misalignments depending on certain variables such as the
size of the tab.  As such, I am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet and am
therefore refraining from solving a problem that does not affect me.

Note that ~tab-always-indent~ will first do indentation and then try to complete
whatever you have typed in.

#+begin_src emacs-lisp
(setq-default tab-always-indent t)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default indent-tabs-mode nil)
#+end_src

*** Syntax highlighting powered by tree-sitter (treesit.el)
:PROPERTIES:
:CUSTOM_ID: h:9A2141F6-3085-4E4D-958C-466E4A16D9BE
:END:

=treesit.el= (built-in with Emacs29+) is an Emacs binding for Tree-sitter, an
incremental parsing system.

It aims to be the foundation for a new breed of Emacs packages that understand
code structurally. For example:

- Faster, fine-grained code highlighting.
- More flexible code folding.
- Structural editing (like Paredit, or even better) for non-Lisp code.
- More informative indexing for imenu.

After setting the ~treesit-language-source-alist~, try =M-x
treesit-install-language-grammar=.

See: https://www.masteringemacs.org/article/how-to-get-started-tree-sitter for
details.

#+begin_src emacs-lisp
(setq treesit-language-source-alist
      '((bash "https://github.com/tree-sitter/tree-sitter-bash")
        (cmake "https://github.com/uyha/tree-sitter-cmake")
        (c-sharp "https://github.com/tree-sitter/tree-sitter-c-sharp")
        (css "https://github.com/tree-sitter/tree-sitter-css")
        (elisp "https://github.com/Wilfred/tree-sitter-elisp")
        (go "https://github.com/tree-sitter/tree-sitter-go")
        (html "https://github.com/tree-sitter/tree-sitter-html")
        (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
        (json "https://github.com/tree-sitter/tree-sitter-json")
        (lua "https://github.com/tree-sitter-grammars/tree-sitter-lua")
        (make "https://github.com/alemuller/tree-sitter-make")
        (markdown "https://github.com/ikatyang/tree-sitter-markdown")
        (python "https://github.com/tree-sitter/tree-sitter-python")
        (toml "https://github.com/tree-sitter/tree-sitter-toml")
        (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
        (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
        (yaml "https://github.com/ikatyang/tree-sitter-yaml")
        (clojure "https://github.com/sogaiu/tree-sitter-clojure")
        (rust "https://github.com/tree-sitter/tree-sitter-rust")
        (vue "https://github.com/ikatyang/tree-sitter-vue")))

(setq treesit-font-lock-level 2)
;; (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:C1A34439-1A4C-4A32-9FEE-2A22CF785336
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+Basic_editing_utilities.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defadvice! delete-backward-char-ad (fn &rest args)
  "Do not try to delete char when the last char is read-only."
  :around #'delete-backward-char
  (unless (get-text-property (1- (point)) 'read-only) (apply fn args)))

;;;###autoload
(defadvice! next-error-no-select-ad (fn &rest args)
  "Do not open new window when calling `next-error-no-select'."
  :around #'next-error-no-select
  (let ((split-width-threshold nil)) (apply fn args)))

;;;###autoload
(defadvice! previous-error-no-select-ad (fn &rest args)
  "Do not open new window when calling `previous-error-no-select'."
  :around #'previous-error-no-select
  (let ((split-width-threshold nil)) (apply fn args)))

;;;###autoload
(defadvice! yank-ad (&rest _)
  "Make `yank' behave like paste (p) command in vim."
  :before #'yank
  (when-let* ((clip (condition-case nil (current-kill 0 t) (error ""))))
    (set-text-properties 0 (length clip) nil clip)
    (when (string-suffix-p "\n" clip)
      (goto-char (line-beginning-position)))))

;;;###autoload
(defun +simple-pop-local-mark-ring ()
  "Move cursor to last mark position of current buffer.
Call this repeatedly will cycle all positions in `mark-ring'."
  (interactive)
  (set-mark-command t))

;;;###autoload
(defun +simple-join-line ()
  "Join the current line with the line beneath it."
  (interactive)
  (delete-indentation 1))

;;;###autoload
(defun +simple-mark-inner-line ()
  "Mark inner line and move cursor to bol."
  (interactive)
  (save-window-excursion
    (move-end-of-line 1)
    (set-mark-command nil)
    (back-to-indentation)))

;; Copied from `xah-fly-keys'
;;;###autoload
(defun +toggle-letter-case ()
  "Toggle the letter case of current word or selection.
Always cycle in this order: Init Caps, ALL CAPS, all lower.
URL `http://xahlee.info/emacs/emacs/modernization_upcase-word.html'
Version: 2020-06-26"
  (interactive)
  (let ((deactivate-mark nil) $p1 $p2)
    (if (region-active-p)
        (setq $p1 (region-beginning) $p2 (region-end))
      (save-excursion
        (skip-chars-backward "[:alpha:]")
        (setq $p1 (point))
        (skip-chars-forward "[:alpha:]")
        (setq $p2 (point))))
    (when (not (eq last-command this-command))
      (put this-command 'state 0))
    (cond
     ((equal 0 (get this-command 'state))
      (upcase-initials-region $p1 $p2)
      (put this-command 'state 1))
     ((equal 1 (get this-command 'state))
      (upcase-region $p1 $p2)
      (put this-command 'state 2))
     ((equal 2 (get this-command 'state))
      (downcase-region $p1 $p2)
      (put this-command 'state 0)))))
#+end_src

** Modal Editing On Wish - meow!
:PROPERTIES:
:CUSTOM_ID: h:CDB8D834-C18F-4B3E-BAE8-98BBDFE5095B
:END:

Unlike =evil-mode=, which tries to create a whole vim emulation in emacs, =meow=
only focus on bringing the goodness of modal editing to vanilla emacs.

You may noticed that I didn't include any keybindings of meow here, that's
because it can be very lengthy and should be configured separately, see
[[#h:95E86308-81E7-4A9F-B457-1EE8F8F80896][Keybindings]] for details.  A very good meow tutorial is built-in with meow, just
type =M-x meow-tutor= and enjoy your learning trip!

Check out [[https://www.github.com/DoglooksGood/meow][meow]] for more about meow or modal editing in general.

#+begin_src emacs-lisp
(use-package meow :ensure t :after-call pre-command-hook)

(meow-global-mode)

(with-eval-after-load 'meow
  (setq meow-visit-sanitize-completion nil)
  (setq meow-use-clipboard t)
  (setq meow-esc-delay 0.001)
  (setq meow-keypad-start-keys '((?c . ?c) (?x . ?x) (?h . ?h)))
  (setq meow-keypad-describe-delay 0.5)
  (setq meow-select-on-change t)
  (setq meow-cursor-type-normal 'box)
  (setq meow-cursor-type-insert '(bar . 2))
  (setq meow-cursor-type-default 'hbar)
  (setq meow-selection-command-fallback
        '((meow-replace . meow-yank)
          (meow-reverse . back-to-indentation)
          (meow-change . meow-change-char)
          (meow-save . +meow-save-line)
          (meow-kill . meow-kill-whole-line)
          (meow-pop-selection . meow-pop-grab)
          (meow-beacon-change . meow-beacon-change-char)
          (meow-cancel . keyboard-quit)
          (meow-delete . meow-C-d)))
  (setq meow-char-thing-table
        '((?r . round) (?b . square) (?c . curly) (?s . string) (?e . symbol)
          (?w . window) (?B . buffer) (?p . paragraph) (?< . line) (?> . line)
          (?d . defun) (?i . indent) (?x . extend) (?. . sentence)))
  (appendq! meow-mode-state-list
            '((helpful-mode . normal)
              (Man-mode . normal)
              (message-buffer-mode . normal))))
#+end_src

*** Keymaps for leader key
:PROPERTIES:
:CUSTOM_ID: h:E5232E0D-670F-487F-BA8C-50396998807A
:END:

Being able to use =SPC= as the *leader* key is one of the killing features of modal
editing.  Prees =SPC x SPC f= in sequence takes 4 keystroke indeed, which looks
longer than =C-x C-f=, but it is objectively easier than holding the control key
while press another letter key (=C-c C-c=).  Using modifiers (ctrl/shift/alt etc.)
in your shortcuts too much usually intensify the risk of getting repetitive
strain injury (RSI).  Maximize the usage of leader key will help to reduce RSI
for those who use the keyboard for long periods of time.

We defined a few keymaps in *grandview* and bind them to the leader key (=SPC=).

+ =grandview-file-map=:       File manipulations, dired, etc.
+ =grandview-mct-map=:        "Minibuffer and Completions in Tandem"
+ =grandview-prog-map=:       Programming related commands
+ =grandview-workspace-map=:  Commands related to windows/workspaces
+ =grandview-util-map=:       Useful utils such as, set frame opacity, etc.
+ =grandview-reg-map=:        Keymap for subcommands of \\`C-x r'.
+ =grandview-project-map=:    Project commands.

=grandview-workspace-map= is actually the alias for =tab-prefix-map=.
=grandview-reg-map= is actually the alias for =ctl-x-r-map=.
=grandview-project-map= is actually the alias for =project-prefix-map=.

#+begin_src emacs-lisp
(define-prefix-command 'grandview-file-map)
(define-prefix-command 'grandview-mct-map)
(define-prefix-command 'grandview-prog-map)
(define-prefix-command 'grandview-util-map)
(define-prefix-command 'grandview-workspace-map)
(define-prefix-command 'grandview-reg-map)
(define-prefix-command 'grandview-project-map)
(defalias 'grandview-workspace-map tab-prefix-map)
(defalias 'grandview-reg-map ctl-x-r-map)
(defalias 'grandview-project-map project-prefix-map)
#+end_src

*** Quick goto char (avy.el)
:PROPERTIES:
:CUSTOM_ID: h:6456CB8B-6280-41C6-8BAC-CB11A7BD9E20
:END:

Jump to any visible text with a few strokes.

#+begin_src emacs-lisp
(use-package avy :ensure t)

(setq avy-timeout-seconds 0.3)
(setq avy-all-windows nil)
(setq avy-keys '(?a ?r ?s ?t ?n ?e ?i ?o))
#+end_src

*** Symbol pairs (embrace.el)
:PROPERTIES:
:CUSTOM_ID: h:250F31DC-B2AB-47A5-A0A9-25C76E962E7E
:END:

=embrace.el= is a package for symbol pairs insert/change/delete which resembles to
=surround.vim= in vim.

I've forked this package to extract =embrace-default-pairs= out, so we can use
keys like ~,r~ to select an inner parenthesis block (this assumes your comma key
has been bound to =meow-inner-of-thing=.)

#+begin_src emacs-lisp
(use-package embrace :vc (:url "https://github.com/alexluigit/embrace.el"))

(setq embrace-default-pairs
      '((?r . ("(" . ")"))
        (?R . ("( " . " )"))
        (?c . ("{" . "}"))
        (?C . ("{ " . " }"))
        (?\[ . ("[" . "]"))
        (?\] . ("[ " . " ]"))
        (?a . ("<" . ">"))
        (?A . ("< " . " >"))
        (?s . ("\"" . "\""))
        (?\' . ("\'" . "\'"))
        (?` . ("`" . "`"))))
#+end_src

*** Keybindings
:PROPERTIES:
:CUSTOM_ID: h:95E86308-81E7-4A9F-B457-1EE8F8F80896
:END:

This section contains *core* keybindings of *Grandview*, feel free to adjust it to
your liking.  Since this part contains so many core keybindings, it's not a good
idea to comment out (in =org-mode= using ~C-c ;~) this section entirely.

**** Orientation
:PROPERTIES:
:CUSTOM_ID: h:A8AA0EF4-27AA-44EA-A933-EFBC1009B16C
:END:

For historical reason, terminal can not tell the difference between some key
storkes. For example, =C-i= and =tab=, =C-m= and =Return=, etc. By default, emacs follow
this convention, but it doesn't mean emacs are not able to tell the
difference. On GUI, we can use ~input-decode-map~ to give =C-i= different meaning.
On terminal, we rebind =<f3>= to =C-i=, so make sure you have relevant settings in
your terminal emulator's settings.

#+begin_src emacs-lisp
(define-key input-decode-map [?\C-i] [C-i])
#+end_src

macOS specific settings.

#+begin_src emacs-lisp
(setq ns-command-modifier 'super)
(setq ns-alternate-modifier 'meta)
#+end_src

**** INSERT
:PROPERTIES:
:CUSTOM_ID: h:CE42BEF3-7ED7-46DF-B4AC-B32AAFBAE529
:END:

#+begin_src emacs-lisp
(define-key meow-insert-state-keymap (kbd "S-<backspace>") 'meow-kill-whole-line)
(define-key meow-insert-state-keymap (kbd "<C-i>") 'meow-right)
(define-key meow-insert-state-keymap (kbd "C-o") 'meow-left)
#+end_src

**** NORMAL
:PROPERTIES:
:CUSTOM_ID: h:B82246F0-CABC-48E4-AE8F-FDAAD6CFDC4F
:END:

#+begin_src emacs-lisp
(meow-normal-define-key
 '("0" . meow-digit-argument)
 '("1" . meow-digit-argument)
 '("2" . meow-digit-argument)
 '("3" . meow-digit-argument)
 '("4" . meow-digit-argument)
 '("5" . meow-digit-argument)
 '("6" . meow-digit-argument)
 '("7" . meow-digit-argument)
 '("8" . meow-digit-argument)
 '("9" . meow-digit-argument)
 '("<escape>" . meow-escape-or-normal-modal)
 '("<backspace>" . meow-pop-selection)
 '(";" . meow-cancel-selection)
 '("," . meow-inner-of-thing)
 '("." . meow-bounds-of-thing)
 '("%" . +meow-insert-at-indentation)
 '("-" . negative-argument)
 '("=" . meow-query-replace)
 '("+" . meow-query-replace-regexp)
 '("^" . meow-last-buffer)
 '("a" . meow-append)
 '("A" . meow-insert)
 '("b" . meow-back-symbol)
 '("B" . meow-block)
 '("c" . meow-change)
 '("C" . meow-change-save)
 '("d" . meow-delete)
 '("D" . meow-backward-delete)
 '("e" . meow-end-of-thing)
 '("E" . meow-beginning-of-thing)
 '("f" . meow-next-symbol)
 '("F" . meow-till)
 '("g" . meow-grab)
 '("G" . meow-sync-grab)
 '("h" . embrace-add)
 '("H" . embrace-commander)
 '("i" . meow-right)
 '("I" . meow-right-expand)
 '("j" . +simple-join-line)
 '("J" . meow-join)
 '("k" . meow-kill)
 '("K" . meow-C-k)
 '("l" . meow-line)
 '("L" . +simple-mark-inner-line)
 '("m" . meow-mark-word)
 '("M" . meow-mark-symbol)
 '("n" . meow-next)
 '("N" . meow-open-below)
 '("o" . meow-left)
 '("O" . meow-left-expand)
 '("p" . meow-prev)
 '("P" . meow-open-above)
 '("q" . quit-window)
 '("Q" . meow-kmacro-lines)
 '("r" . meow-reverse)
 '("R" . undo-redo)
 '("s" . meow-search)
 '("S" . meow-pop-search)
 '("t" . avy-goto-char-timer)
 '("T" . avy-resume)
 '("u" . meow-undo)
 '("U" . meow-undo-in-selection)
 '("v" . meow-visit)
 '("w" . meow-next-word)
 '("W" . meow-back-word)
 '("x" . meow-save)
 '("X" . meow-replace)
 '("y" . meow-yank)
 '("Y" . meow-yank-pop)
 '("z" . meow-beacon-start)
 '("Z" . meow-end-or-call-kmacro))
#+end_src

**** LEADER
:PROPERTIES:
:CUSTOM_ID: h:5D69FCEA-9C0B-4EB9-8C03-E0AF1A4EB46C
:END:

#+begin_src emacs-lisp
(meow-leader-define-key
 '("0" . delete-window)
 '("1" . delete-other-windows)
 '("2" . split-window-below)
 '("3" . split-window-right)
 '("4" . ctl-x-4-prefix)
 '("5" . ctl-x-5-prefix)
 '("8" . insert-char)
 '("9" . grandview-tab-map)
 '("/" . xref-find-references)
 '(";" . comment-line)
 '("," . xref-go-back)
 '("." . xref-find-definitions)
 '("<" . beginning-of-buffer)
 '(">" . end-of-buffer)
 '("a" . grandview-util-map)
 '("e" . dired-jump)
 '("E" . eval-expression)
 '("f" . grandview-file-map)
 '("i" . ibuffer)
 '("k" . kill-current-buffer)
 '("n" . +project-find-file)
 '("o" . grandview-prog-map)
 '("p" . grandview-project-map)
 '("r" . grandview-reg-map)
 '("t" . grandview-mct-map)
 '("w" . grandview-workspace-map)
 '("z" . window-toggle-side-windows))

(define-key grandview-util-map (kbd "d") 'toggle-debug-on-error)
(define-key grandview-util-map (kbd "o") '+frame-opacity-set)
(define-key grandview-util-map (kbd "t") 'toggle-frame-maximized)
(define-key grandview-util-map (kbd "=") 'count-words)
(define-key grandview-util-map (kbd "m") '+show-messages)
#+end_src

**** GLOBAL
:PROPERTIES:
:CUSTOM_ID: h:46996B4B-A490-4981-B583-51ED036305CD
:END:

All major bindings work globally.

#+begin_src emacs-lisp
(define-key global-map (kbd "<f3>") '+simple-pop-local-mark-ring)
(define-key global-map (kbd "s-SPC") '+monocle-mode) ; replaced `just-one-space'
(define-key global-map (kbd "S-SPC") 'toggle-input-method)
(define-key global-map (kbd "s-u") '+toggle-letter-case)
(define-key global-map (kbd "<C-i>") '+simple-pop-local-mark-ring)
(define-key global-map (kbd "C-o") 'pop-global-mark)
(define-key global-map (kbd "s-o") 'other-window)
(define-key global-map (kbd "M-n") 'scroll-up-command)
(define-key global-map (kbd "M-p") 'scroll-down-command)
(define-key global-map (kbd "s-n") 'forward-paragraph)
(define-key global-map (kbd "s-p") 'backward-paragraph)
(define-key minibuffer-local-map (kbd "<mouse-8>") 'exit-minibuffer)
(define-key minibuffer-local-map (kbd "S-<backspace>") 'meow-kill-whole-line)
(define-key minibuffer-local-map (kbd "<f3>") 'forward-char)
(define-key minibuffer-local-map (kbd "<C-i>") 'forward-char)
(define-key minibuffer-local-map (kbd "C-o") 'backward-char)
(define-key meow-insert-state-keymap (kbd "<f3>") 'meow-right)
(define-key image-map (kbd "o") nil)
(define-key image-map (kbd "w") 'image-save)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:3050E51B-BD81-4574-B257-232C450D998B
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+Modal_Editing_On_Wish_-_meow!.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defadvice! meow-search-ad (&rest _)
  "Do not highlight number positions."
  :after #'meow-search
  (recenter))

;;;###autoload
(defadvice! meow-query-replace-ad (&rest _)
  "Call `meow-query-replace' and auto fill prompt with region text."
  :before #'meow-query-replace
  (unless (region-active-p) (meow-mark-symbol 1))
  (let ((text (buffer-substring-no-properties (region-beginning) (region-end))))
    (exchange-point-and-mark)
    (deactivate-mark t)
    (run-with-timer 0.05 nil 'insert text)))

;;;###autoload
(defadvice! meow-insert-exit-ad (&rest _)
  "Quit `completion-in-region-mode' after `meow-insert-exit'."
  :after #'meow-insert-exit
  (completion-in-region-mode -1))

;;;###autoload
(defadvice! meow-inhibit-highlight-num-positions-ad (&rest _)
  "Do not highlight number positions."
  :override #'meow--maybe-highlight-num-positions
  (ignore))

;;;###autoload
(defun +meow-insert-at-indentation ()
  "Insert at first non-whitespace point at current line."
  (interactive)
  (back-to-indentation)
  (meow-insert))

;;;###autoload
(defun +meow-save-line ()
  "Fallback command for `meow-save'."
  (interactive)
  (let ((beg (if (eobp)
                 (line-beginning-position 0)
               (line-beginning-position)))
        (end (line-beginning-position 2)))
    (kill-ring-save beg end)))
#+end_src

** User interface basics
:PROPERTIES:
:CUSTOM_ID: h:110DCD38-DDFE-40D6-BC73-7DC3C229A0E7
:END:

This section contain configs in relation to basic user interface such as scroll
behavior, font settings , theme, etc.

Here are some basic tweaks:

+ Show current key strokes in echo area after 0.25s
+ Disable bidirectional text scanning for a modest performance boost.
+ Do not display continuation lines
+ Do not disable the ~erase-buffer~ command

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the
viewport.  This eliminates the friction of guessing where the point
has warped to.

As for per-line scrolling, I dislike the default behaviour of
visually re-centring the point: it is too aggressive as a standard
mode of interaction.  With the following setq-default, the point
will stay at the top/bottom of the screen while moving in that
direction (use =C-l= to reposition it).

#+begin_src emacs-lisp
(setq-default bidi-display-reordering 'left-to-right)
(setq-default bidi-paragraph-direction 'left-to-right)
(setq bidi-inhibit-bpa t)
(setq-default truncate-lines t)
(setq echo-keystrokes 0.25)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq scroll-step 1)
(setq scroll-margin 1)
(setq hscroll-step 1)
(setq hscroll-margin 1)
(put 'erase-buffer 'disabled nil)
#+end_src

*** Themes
:PROPERTIES:
:CUSTOM_ID: h:19F22F8C-F10D-48E0-8157-41D4836D2F6A
:END:

Recommended themes (using their package names):

- =modus-vivendi=
  A built-in theme in emacs (version >= 28) created by Protesilaos Stavrou.

- =ef-themes=
  Yet another theme suite developed by Prot.

- =doom-themes=
  A megapack of popular themes, including aesthetic extensions
  for popular packages.

- =apropospriate-theme=
  Apropospriate theme.

- =lambda-themes=
  Lambda themes.

- =color-theme-sanityinc-tomorrow=
  SanityInc tomorrow theme.

- =mindre-theme=
  Mindre theme.

#+begin_src emacs-lisp
(use-package modus-themes :ensure nil :after-call after-init-hook)

;; (use-package ef-themes :ensure t :after-call after-init-hook)
;; (use-package lambda-themes :vc (:url "https://github.com/Lambda-Emacs/lambda-themes"))
;; (use-package apropospriate-theme :ensure t)
;; (use-package doom-themes :ensure t)
;; (use-package color-theme-sanityinc-tomorrow :ensure t)
;; (use-package mindre-theme :ensure t)

;; (with-eval-after-load 'ef-themes
;;   (setq ef-themes-to-toggle '(ef-summer ef-winter)
;;     ef-themes-mixed-fonts t
;;     ef-themes-variable-pitch-ui t))

(with-eval-after-load 'modus-themes
  (setq modus-themes-common-palette-overrides
        '((underline-link unspecified)
          (underline-link-visited unspecified)
          (underline-link-symbolic unspecified))))

(add-hook 'after-init-hook (lambda () (load-theme grandview-theme t)))
#+end_src

*** Fonts and icons
:PROPERTIES:
:CUSTOM_ID: h:B50A7C8A-7553-46CF-92B8-56865009C681
:END:

Here are some recommended fonts for programming or general text editing.

- =Victor Mono=
- =Sarasa Mono SC=
- =Fira Code Retina=

A list of my favorite CJK fonts.

- =LXGW WenKai Mono=
- =HarmonyOS Sans SC Light=
- =Smartisan Compact CNS=

+ ~grandview-font-size~: Font size being applied.
+ ~grandview-default-font~: The default font
+ ~grandview-fixed-font~: The =fixed-pitch= font
+ ~grandview-variable-font~: The =variable-pitch= font
+ ~grandview-CJK-font~: The font used for CJK characters.

Please make sure the font you choose can be recognized by Emacs, you can varify
that by evaluating:

#+begin_src emacs-lisp
(member "Sarasa Mono SC" (font-family-list))
#+end_src

#+begin_src emacs-lisp
(if (daemonp)
    (add-hook 'after-make-frame-functions #'+font-setup)
  (+font-setup))
#+end_src

*** Icon library (nerd-icons.el)
:PROPERTIES:
:CUSTOM_ID: h:14F5303D-F1A6-48D0-83AF-E4F8F34EC946
:END:

#+begin_src emacs-lisp
(use-package nerd-icons :ensure t)

(require 'nerd-icons)
(setq nerd-icons-font-family "Iosevka Nerd Font")
(when (memq system-type '(ms-dos cygwin windows-nt))
  (setq nerd-icons-font-family "Iosevka NF"))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:38943ED3-0842-4327-9998-3E331FAA76DB
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+User_interface_basics.el"
:END:

#+begin_src emacs-lisp
(defcustom grandview-theme 'modus-vivendi
  "Default theme for grandview.")

(defcustom grandview-font-size 140
  "Default font size for grandview.")

(defcustom grandview-default-font "Iosevka Nerd Font Mono"
  "Default font for grandview.")

(defcustom grandview-fixed-font "Sarasa Mono SC"
  "Default fixed font for grandview.")

(defcustom grandview-variable-font "Sarasa Mono SC"
  "Default variable font for grandview.")

(defcustom grandview-CJK-font "LXGW WenKai Mono"
  "Default CJK font (Chinese/Japanese/Korean) for grandview.")

;;;###autoload
(defun +font-setup (&optional frame)
  "Setup default/fixed-pitch/variable-pitch/zh-font."
  (cl-loop with font-families = (font-family-list frame)
           for font in (list grandview-default-font grandview-fixed-font
                             grandview-variable-font)
           for name in '(default fixed-pitch variable-pitch)
           if (member font font-families) do
           (custom-theme-set-faces
            'user `(,name ((t (:font ,font :height ,grandview-font-size)))))
           else do (message "Font `%s' is not available" font)
           finally
           (progn
             (custom-theme-set-faces
              'user
              '(font-lock-keyword-face ((t (:slant italic))))
              '(font-lock-variable-name-face ((t (:weight demibold))))
              '(font-lock-function-name-face ((t (:weight demibold)))))
             (if (member grandview-CJK-font font-families)
                 (dolist (charset '(kana han cjk-misc bopomofo))
                   (set-fontset-font t charset (font-spec :family grandview-CJK-font)))
               (message "Font `%s' is not available" grandview-CJK-font))
             (unless (> emacs-major-version 27)
               (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji"))))))

;;;###autoload
(defun +font-cn-set-title (beg end)
  (interactive "r")
  (remove-overlays beg end)
  (let ((ov (make-overlay beg end)))
    (overlay-put ov 'display '(height 1.5))))

;;;###autoload
(defun +font-cn-set-quote (beg end)
  (interactive "r")
  (remove-overlays beg end)
  (let ((ov (make-overlay beg end)))
    (overlay-put ov 'face 'font-lock-comment-face)))
#+end_src

** Use Emacs like a Desktop Environment
:PROPERTIES:
:CUSTOM_ID: h:E630E73C-36CF-4530-AB9F-C45176D23EFD
:END:

*** Buffer management (ibuffer.el)
:PROPERTIES:
:CUSTOM_ID: h:0A906F33-AF6F-4265-813E-78B8D76B0FA5
:END:

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.

#+begin_src emacs-lisp
(use-package ibuffer :ensure nil)

(with-eval-after-load 'ibuffer
  (add-hook 'ibuffer-mode-hook
            (lambda () (hl-line-mode) (ibuffer-update 0)))
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  ;; (setq ibuffer-never-show-predicates '("^ \\*.*"))
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " " (name 16 -1) " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (define-key ibuffer-mode-map (kbd "* f") 'ibuffer-mark-by-file-name-regexp)
  (define-key ibuffer-mode-map (kbd "* g") 'ibuffer-mark-by-content-regexp)
  (define-key ibuffer-mode-map (kbd "* n") 'ibuffer-mark-by-name-regexp)
  (define-key ibuffer-mode-map (kbd "s n") 'ibuffer-do-sort-by-alphabetic)
  (define-key ibuffer-mode-map (kbd "/ g") 'ibuffer-filter-by-content))
#+end_src

*** Window management (window.el)
:PROPERTIES:
:CUSTOM_ID: h:1A9091D5-B8A4-4135-9415-9823ABF0AF3C
:END:

**** Window selection (windmove.el)
:PROPERTIES:
:CUSTOM_ID: h:D0621A73-5618-478E-B8C9-59A798B3BA15
:END:

Directional window-selection routines.

#+begin_src emacs-lisp
(use-package windmove :ensure nil :after-call split-window)

(with-eval-after-load 'windmove
  (define-key 'grandview-workspace-map (kbd "C-w d") 'windmove-swap-states-down)
  (define-key 'grandview-workspace-map (kbd "C-w u") 'windmove-swap-states-up)
  (define-key 'grandview-workspace-map (kbd "C-w r") 'windmove-swap-states-right)
  (define-key 'grandview-workspace-map (kbd "C-w l") 'windmove-swap-states-left))
#+end_src

**** Window placement
:PROPERTIES:
:CUSTOM_ID: h:72ECA0DF-D43C-4E28-92A9-CB830B99B85A
:END:

The =display-buffer-alist= is intended as a rule-set for controlling the display
of windows.  The objective is to create a more intuitive workflow where targeted
buffer groups or types are always shown in a given location, on the premise that
predictability improves usability.

For each buffer action in it we can define several functions for selecting the
appropriate window.  These are executed in sequence, but my usage thus far
suggests that a simpler method is just as effective for my case.

Disable ~cursor-in-non-selected-windows~ and ~highlight-nonselected-windows~ reduces
rendering/line scan work for Emacs in non-focused windows.

#+begin_src emacs-lisp
(use-package window :ensure nil)

(with-eval-after-load 'window
  (setq-default cursor-in-non-selected-windows nil)
  (setq highlight-nonselected-windows nil)
  (setq display-buffer-alist
        `(("\\*\\(Flymake\\|Backtrace\\|Warnings\\|Compile-Log\\|Custom\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.2)
           (side . top))
          ("^\\*\\(Help\\|helpful\\).*"
           (display-buffer-in-side-window)
           (window-width . 0.4)
           (side . right))
          ("\\*\\vc-\\(incoming\\|outgoing\\|Output\\|Register Preview\\).*"
           (display-buffer-at-bottom))
          ("\\*compilation\\*"
           (display-buffer-in-side-window)
           (window-height . 0.2)
           (side . bottom))))
  (setq help-window-select t)
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (setq split-height-threshold nil)
  (setq split-width-threshold 120))
#+end_src

**** Autoload
:PROPERTIES:
:CUSTOM_ID: h:7BAA0631-CBD3-4BED-BB6B-D6BE35BDBA73
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+window.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +show-messages (&optional erase)
  "Show *Messages* buffer in other frame.
If ERASE is non-nil, erase the buffer before switching to it."
  (interactive "P")
  (when erase
    (let ((inhibit-read-only t))
      (with-current-buffer "*Messages*" (erase-buffer))))
  (let ((win (get-buffer-window "*Messages*" t))
        (after-make-frame-functions nil))
    (if (window-live-p win)
        (delete-frame (window-frame win))
      (with-selected-frame (make-frame)
        (set-window-parameter (selected-window) 'no-other-window t)
        (switch-to-buffer "*Messages*")))))

(defvar +monocle--saved-window-configuration nil
  "Last window configuration before enabling `+monocle-mode'.")

;;;###autoload
(define-minor-mode +monocle-mode
  "Toggle between multiple windows and single window.
This is the equivalent of maximising a window.  Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
  :global t
  (let ((config +monocle--saved-window-configuration)
        (buf (current-buffer)))
    (if (one-window-p)
        (when config
          (set-window-configuration config))
      (setq +monocle--saved-window-configuration (current-window-configuration))
      (when (window-parameter nil 'window-side) (delete-window))
      (delete-other-windows)
      (switch-to-buffer buf))))
#+end_src

*** Frame parameters (frame.el)
:PROPERTIES:
:CUSTOM_ID: h:F715736C-9299-489F-96A4-C43C649C883A
:END:

- Remove title bar on macOS
- Enter fullscreen automatically on macOS
- Adjust frame opacity dynamically

#+begin_src emacs-lisp
(when  (eq system-type 'darwin)
  (add-to-list 'default-frame-alist '(undecorated . t))
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))

(when (> emacs-major-version 28)
  (add-hook 'window-configuration-change-hook #'+frame-opacity-auto))
#+end_src

**** Autoload
:PROPERTIES:
:CUSTOM_ID: h:5FD0BB42-46A7-4814-8F35-A7FF80DAFBB3
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+frame.el"
:END:

#+begin_src emacs-lisp
(defvar +frame-cursor-saved-color
  (frame-parameter nil 'cursor-color))

(defcustom +frame-cursor-dim-color "#606060"
  "Cursor color for `+frame-cursor-dim-mode'."
  :group 'cursor :type 'string)

(defcustom +frame-opacity 100
  "Default frame opacity."
  :group 'grandview
  :type 'integer)

(defun +frame-opacity--adjust (opacity)
  (pcase system-type
    ('darwin (set-frame-parameter nil 'alpha `(,opacity ,opacity)))
    (_ (set-frame-parameter nil 'alpha-background opacity))))

;;;###autoload
(defun +frame-opacity-auto ()
  "Setup frame opacity according to current major-mode."
  (+frame-opacity--adjust +frame-opacity))

;;;###autoload
(defun +frame-opacity-set (&optional percent)
  (interactive "P")
  (cond ((or (and percent (not current-prefix-arg))
             (numberp percent))
         (setq +frame-opacity (* 10 percent))
         (+frame-opacity--adjust +frame-opacity))
        ((equal current-prefix-arg '(4))
         (+frame-opacity--adjust +frame-opacity))
        (t (let ((opa (frame-parameter nil 'alpha-background))
                 (low 60) (high 100))
             (+frame-opacity--adjust (if (eq opa low) high low))))))

;;;###autoload
(define-minor-mode +frame-cursor-dim-mode
  "Enable dimmed `cursor-color' for current frame."
  :global t
  :lighter nil
  :group 'cursor
  (if +frame-cursor-dim-mode
      (progn
        (setq-local cursor-type nil)
        (blink-cursor-mode -1)
        (set-cursor-color +frame-cursor-dim-color))
    (blink-cursor-mode +1)
    (set-cursor-color +frame-cursor-saved-color)))
#+end_src

*** Running Emacs as server process (server.el)
:PROPERTIES:
:CUSTOM_ID: h:0CA633D0-896A-4396-BF65-4C6807A5FE16
:END:

This library allows Emacs to operate as a server for other processes.

During init, we enable Emacs as a server unless there is a running server.
Emacs opens up a socket for communication with clients.  If there are no client
buffers to edit, =server-edit= acts like =(switch-to-buffer (other-buffer))=.

When some other program runs "the editor" to edit a file, "the editor" can be
the Emacs client program =emacsclient=.  This program transmits the file names to
Emacs through the server subprocess, and Emacs visits them and lets you edit
them.

Note that any number of clients may dispatch files to Emacs to be edited.

#+begin_src emacs-lisp
(use-package server :ensure nil :after-call after-init-hook)

(with-eval-after-load 'server
  (require 'server)
  (unless (server-running-p) (server-start))
  (select-frame-set-input-focus (selected-frame)))
#+end_src

** COMMENT Persistent sessions (desktop.el)
:PROPERTIES:
:CUSTOM_ID: h:FD3E91E4-0457-47EA-B98E-E8D0ECD7524F
:END:

#+begin_src emacs-lisp
(desktop-save-mode 1)
#+end_src

* Completion framework
:PROPERTIES:
:CUSTOM_ID: h:50E17583-1B94-4453-83B8-6E05260EA03D
:END:

The optimal way of using Emacs is through searching and narrowing selection
candidates.  Spend less time worrying about where things are on the screen and
more on how fast you can bring them into focus.  This is, of course, a matter of
realigning priorities, as we still wish to control every aspect of the
interface.

The auto completion functionality (especially in the minibuffer) is a one of the
fundamental components in *Grandview*.  Unless you encounter one or more issues
related to package configs in this section, I would *NOT* advise you to comment
out (in =org-mode= using ~C-c ;~) this section entirely, because debugging emacs
often involves with manually typing commands in the minibuffer.  That said, feel
free to tweak configuartions in this section.

** Minibuffer and completion functions (minibuffer.el)
:PROPERTIES:
:CUSTOM_ID: h:97388408-518C-4774-968C-23C71CFE8599
:END:

The minibuffer is the epicentre of extended interactivity with all sorts of
Emacs workflows: to select a buffer, open a file, provide an answer to some
prompt, such as a number, regular expression, password, and so on.

What my minibuffer config does:

- Intangible cursors ::

  Disallow user move cursors into prompt.

- Recursive minibuffers ::

  Enable recursive minibuffers.  This practically means that you can start
  something in the minibuffer, switch to another window, call the minibuffer
  again, run some commands, and then move back to what you initiated in the
  original minibuffer.  Or simply call an =M-x= command while in the midst of a
  minibuffer session.  To exit, hit =C-[= (=abort-recursive-edit=), though the
  regular =C-g= should also do the trick.

  The =minibuffer-depth-indicate-mode= will show a recursion indicator,
  represented as a number, next to the minibuffer prompt, if a recursive
  edit is in progress.

#+begin_src emacs-lisp
(use-package minibuffer :ensure nil)
(use-package minibuf-eldef :ensure nil)

(setq enable-recursive-minibuffers t)
(setq minibuffer-eldef-shorten-default t)

(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(minibuffer-depth-indicate-mode 1)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:2DA0D02F-765C-47AE-8118-A4CA24FE9CB5
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+minibuffer.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +minibuffer-append-metadata (metadata candidates)
  "Append METADATA for CANDIDATES."
  (let ((entry (if (functionp metadata)
                   `(metadata (annotation-function . ,metadata))
                 `(metadata (category . ,metadata)))))
    (lambda (string pred action)
      (if (eq action 'metadata)
          entry
        (complete-with-action action candidates string pred)))))
#+end_src

** Minibuffer history (savehist.el)
:PROPERTIES:
:CUSTOM_ID: h:F88C364F-4C13-4C6E-B9A1-20F6CFBDC24F
:END:

Keeps a record of actions involving the minibuffer.

#+begin_src emacs-lisp
(use-package savehist :ensure nil :after-call minibuffer-setup-hook)

(with-eval-after-load 'savehist
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (savehist-mode))
#+end_src

** Vertical completion candidates (vertico.el)
:PROPERTIES:
:CUSTOM_ID: h:0ABB48B0-A43D-4F71-9B2E-5B0C885B82FD
:END:

Vertico provides a performant and minimalistic vertical completion UI based on
the default completion system. By reusing the built-in facilities, Vertico
achieves full compatibility with built-in Emacs completion commands and
completion tables.

Here I just modified face for current candidate and make height of vertico
window as a constant value.

#+begin_src emacs-lisp
(use-package vertico :ensure t :after-call pre-command-hook)

(with-eval-after-load 'vertico (vertico-mode 1))
#+end_src

** Match candidates made easy (orderless.el)
:PROPERTIES:
:CUSTOM_ID: h:C20C20F0-CA95-4CC3-BCF3-42525A72A99F
:END:

This package provides an =orderless= completion style that divides the pattern
into components (space-separated by default), and matches candidates that match
all of the components in any order.

Setup completion styles in minibuffer.

Not that we have set =orderless-component-separator= to the function
=orderless-escapable-split-on-space=.  This allows us to match candidates with
literal spaces.  Suppose you are browsing =dired.el= and try to locate the =dired=
function, you can issue a =consult-outline= command and input "defun dired\ \(\)",
this gives you =(defun dired (dirname &optional switches)= as the sole match
rather than all of the =dired-*= noise.

#+begin_src emacs-lisp
(use-package pinyinlib :ensure t)
(use-package orderless :ensure t)

(with-eval-after-load 'vertico
  (autoload 'pinyinlib-build-regexp-string "pinyinlib")
  (setq completion-styles '(orderless partial-completion basic))
  (setq orderless-component-separator #'orderless-escapable-split-on-space)
  (setq orderless-matching-styles
        '(+orderless-pinyin-only-initialism
          orderless-initialism
          orderless-prefixes
          orderless-regexp))
  (setq orderless-style-dispatchers
        '(+orderless-literal-dispatcher
          +orderless-initialism-dispatcher
          +orderless-without-literal-dispatcher
          +orderless-pinyin-dispatcher)))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:60693C7D-8538-4B1C-83B2-E79C21E72A20
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+orderless.el"
:END:

#+begin_src emacs-lisp
(defun +orderless-pinyin-only-initialism (pattern)
  "Leading pinyin initialism regex generator."
  (if (< (length pattern) 10)
      (pinyinlib-build-regexp-string pattern t nil t)
    pattern))

;;;###autoload
(defun +orderless-literal-dispatcher (pattern _index _total)
  "Literal style dispatcher using the equals sign as a suffix."
  (when (string-suffix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 0 -1))))

;;;###autoload
(defun +orderless-initialism-dispatcher (pattern _index _total)
  "Leading initialism dispatcher using the comma sign as a prefix."
  (when (string-prefix-p "," pattern)
    `(orderless-strict-leading-initialism . ,(substring pattern 1))))

;;;###autoload
(defun +orderless-pinyin-dispatcher (pattern _index _total)
  "Pinyin initialism dispatcher using the backtick sign as a prefix."
  (when (string-prefix-p "`" pattern)
    `(+orderless-pinyin-only-initialism . ,(substring pattern 1))))

;;;###autoload
(defun +orderless-without-literal-dispatcher (pattern _index _total)
  (when (string-prefix-p "~" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

** Useful commands using completion (consult.el)
:PROPERTIES:
:CUSTOM_ID: h:BD952A54-C221-4AE9-BEEC-4B0F24272F33
:END:

Consult implements a set of =consult-<thing>= commands which use
=completing-read= to select from a list of candidates. Consult provides an
enhanced buffer switcher =consult-buffer= and search and navigation commands
like =consult-imenu= and =consult-line=.  Searching through multiple files is
supported by the asynchronous =consult-grep= command. Many Consult commands
allow previewing candidates - if a candidate is selected in the completion view,
the buffer shows the candidate immediately.

The Consult commands are compatible with completion systems based on the Emacs
=completing-read= API, including the default completion system, Icomplete,
Selectrum, Vertico and Embark.

The purpose for setting =consult-async-min-input= to 2 is to adapt for Chinese
word, which usually consists of only 2 characters.

#+begin_src emacs-lisp
(use-package consult :ensure t)

(with-eval-after-load 'vertico
  (setq completion-in-region-function #'consult-completion-in-region)
  (advice-add #'register-preview :override #'consult-register-window)
  (setq register-preview-delay 0.2)
  (setq register-preview-function #'consult-register-format)
  (setq xref-show-xrefs-function #'consult-xref)
  (setq xref-show-definitions-function #'consult-xref)
  (setq consult-line-numbers-widen t)
  (setq consult-async-min-input 2)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (define-key grandview-mct-map (kbd "l") 'consult-line)
  (define-key grandview-mct-map (kbd "/") 'consult-line-multi)
  (define-key grandview-mct-map (kbd "t") 'consult-mark)
  (define-key grandview-mct-map (kbd "T") 'consult-global-mark)
  (define-key grandview-mct-map (kbd "a") 'consult-apropos)
  (define-key grandview-mct-map (kbd "e") 'consult-compile-error)
  (define-key grandview-mct-map (kbd "f") 'consult-flymake)
  (define-key grandview-mct-map (kbd "r") 'consult-ripgrep)
  (define-key grandview-mct-map (kbd "k") 'consult-kmacro)
  (define-key grandview-mct-map (kbd "K") 'consult-keep-lines)
  (define-key grandview-mct-map (kbd "i") 'consult-imenu-multi)
  (define-key grandview-mct-map (kbd "n") 'consult-focus-lines) ; narrow
  (define-key grandview-mct-map (kbd "o") 'consult-outline)
  (define-key grandview-mct-map (kbd "R") 'consult-register)
  (define-key grandview-mct-map (kbd "y") 'consult-yank-from-kill-ring)
  (define-key grandview-mct-map (kbd "m") 'consult-bookmark)
  (define-key grandview-mct-map (kbd "c") 'consult-complex-command)
  (define-key grandview-mct-map (kbd "C") 'consult-mode-command)
  (define-key grandview-mct-map (kbd "M") 'consult-minor-mode-menu))

(with-eval-after-load 'meow
  (meow-normal-define-key
   '("/" . consult-line)
   '("V" . consult-global-mark))
  (meow-leader-define-key '("SPC" . consult-buffer)))
#+end_src

** Candidate annotation (marginalia.el)
:PROPERTIES:
:CUSTOM_ID: h:A08A5E53-E279-4950-AA96-09022CF50A0F
:END:

This is a utility jointly developed by Daniel Mendler and Omar Antolín Camarena
that provides annotations to completion candidates.  It is meant to be
framework-agnostic, so it works with Selectrum, Icomplete, vertico, and Embark.

#+begin_src emacs-lisp
(use-package marginalia :ensure t)

(with-eval-after-load 'vertico
  (marginalia-mode)
  (setq marginalia-align 'left))
#+end_src

** Completion overlay region function (corfu.el)
:PROPERTIES:
:CUSTOM_ID: h:908C6FBC-B6C2-43D3-B696-859B32DAF6ED
:END:

=Corfu= enhances the default completion in region function with a completion
overlay.  The current candidates are shown in a popup below or above the point.
Corfu can be considered the minimalistic completion-in-region counterpart of
=Vertico=.

We also enabled ~corfu-doc-mode~ to show documentation of the candidates in a
pop-up window.

#+begin_src emacs-lisp
(use-package corfu :ensure t :after-call self-insert-command)

(with-eval-after-load 'corfu
  (setq corfu-auto t)
  (setq corfu-auto-delay 0.05)
  (setq corfu-cycle t)
  (setq corfu-preselect 'prompt)
  (setq corfu-on-exact-match nil)
  (global-corfu-mode))
#+end_src

** Completion at point Extensions (cape.el)
:PROPERTIES:
:CUSTOM_ID: h:E3567F74-AFCB-43EE-9A86-7FBF740CFDE3
:END:

Let your completions fly! This package provides additional completion backends
in the form of Capfs (~completion-at-point-functions~).

#+begin_src emacs-lisp
(use-package cape :ensure t :after-call meow-insert-mode-hook)

(with-eval-after-load 'cape
  (setq cape-dict-file "/usr/share/dict/words")
  (when (>= emacs-major-version 30)
    (setopt text-mode-ispell-word-completion nil))
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-keyword)
  (add-hook 'completion-at-point-functions #'cape-dict)
  (define-prefix-command '+cape-map)
  (defvar +cape-prefix-map (make-sparse-keymap))
  (defalias '+cape-map +cape-prefix-map)
  (define-key global-map (kbd "C-M-/") '+cape-map)             ; remapped `dabbrev-completion'
  (define-key +cape-prefix-map (kbd "c") 'completion-at-point) ; capf
  (define-key +cape-prefix-map (kbd "t") 'complete-tag)        ; etags
  (define-key +cape-prefix-map (kbd "d") 'cape-dabbrev)        ; or dabbrev-completion
  (define-key +cape-prefix-map (kbd "f") 'cape-file)
  (define-key +cape-prefix-map (kbd "k") 'cape-keyword)
  (define-key +cape-prefix-map (kbd "s") 'cape-symbol)
  (define-key +cape-prefix-map (kbd "a") 'cape-abbrev)
  (define-key +cape-prefix-map (kbd "i") 'cape-ispell)
  (define-key +cape-prefix-map (kbd "l") 'cape-line)
  (define-key +cape-prefix-map (kbd "w") 'cape-dict)
  (define-key +cape-prefix-map (kbd "\\") 'cape-tex)
  (define-key +cape-prefix-map (kbd "_") 'cape-tex)
  (define-key +cape-prefix-map (kbd "^") 'cape-tex)
  (define-key +cape-prefix-map (kbd "&") 'cape-sgml)
  (define-key +cape-prefix-map (kbd "r") 'cape-rfc1345))
#+end_src

** Snippet (tempel.el)
:PROPERTIES:
:CUSTOM_ID: h:B5025BD7-D74F-4DCF-BA55-1B1E8BD42106
:END:

"Tempel is a tiny template package for Emacs, which uses the syntax of the Emacs
Tempo library. Tempo is an ancient temple of the church of Emacs. It is 30 years
old, but still in good shape since it successfully resisted change over the
decades. However it may look a bit dusty here and there. Therefore we present
Tempel, a new implementation of Tempo with inline expansion and integration with
recent Emacs facilities. Tempel takes advantage of the standard
completion-at-point-functions mechanism which is used by Emacs for in-buffer
completion."

-- From https://github.com/minad/tempel

#+begin_src emacs-lisp
(use-package tempel :ensure t :after-call self-insert-command)

(add-hook 'prog-mode-hook '+tempel-setup-capf)
(add-hook 'text-mode-hook '+tempel-setup-capf)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:BD8323BA-61B7-4216-8A63-B907DA7288C7
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+tempel.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +tempel-setup-capf ()
  ;; Add the Tempel Capf to `completion-at-point-functions'.
  ;; `tempel-expand' only triggers on exact matches. Alternatively use
  ;; `tempel-complete' if you want to see all matches, but then you
  ;; should also configure `tempel-trigger-prefix', such that Tempel
  ;; does not trigger too often when you don't expect it. NOTE: We add
  ;; `tempel-expand' *before* the main programming mode Capf, such
  ;; that it will be tried first.
  (setq-local completion-at-point-functions
              (cons #'tempel-complete completion-at-point-functions)))
#+end_src

*** Templates
:PROPERTIES:
:CUSTOM_ID: h:160AE5D1-274F-432D-B5BF-DA1DE00A889F
:END:

All the Tempo syntax elements are fully supported. The syntax elements are
described in detail in the docstring of ~tempo-define-template~ in tempo.el. We
document the important ones here:

- "string" Inserts a string literal.
- ~p~ Inserts an unnamed placeholder field.
- ~n~ Inserts a newline.
- ~>~ Indents with ~indent-according-to-mode~.
- ~r~ Inserts the current region.
- ~r>~ The region, but indented.
- ~n>~ Inserts a newline and indents.
- ~&~ Insert newline if there is only whitespace between line start and point.
- ~%~ Insert newline if there is only whitespace between point and line end.
- ~o~ Like ~%~ but leaves the point before newline.
- ~(s NAME)~ Inserts a named field.
- ~(p PROMPT <NAME> <NONINS>)~ Insert an optionally named field with a prompt.
  The ~PROMPT~ is displayed directly in the buffer as default value. If ~NOINSERT~
  is non-nil, no field is inserted. Then the minibuffer is used for prompting
  and the value is bound to ~NAME~.
- ~(r PROMPT <NAME> <NOINSERT>)~ Insert region or act like ~(p ...)~.
- ~(r> PROMPT <NAME> <NOINSERT>)~ Act like ~(r ...)~, but indent region.

Furthermore Tempel supports syntax extensions:

- ~(p FORM <NAME> <NONINS>)~ Like ~p~ described above, but ~FORM~ is evaluated.
- ~(FORM ...)~ Other Lisp forms are evaluated. Named fields are lexically bound.
- ~q~ Quits the containing template when jumped to.

Use caution with templates which execute arbitrary code!

#+begin_src lisp :tangle (expand-file-name "templates" user-emacs-directory)
fundamental-mode ;; Available everywhere

(today (format-time-string "%Y-%m-%d"))

prog-mode

(fixme (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "FIXME ")
(todo (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "TODO ")
(bug (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "BUG ")
(hack (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "HACK ")

latex-mode

(begin "\\begin{" (s env) "}" > n> r> "\\end{" (s env) "}")
(frac "\\frac{" p "}{" p "}")
(enumerate "\\begin{enumerate}\n\\item " r> n> "\\end{enumerate}")
(itemize "\\begin{itemize}\n\\item " r> n> "\\end{itemize}")

lisp-mode emacs-lisp-mode ;; Specify multiple modes

(lambda "(lambda (" p ")" n> r> ")")

emacs-lisp-mode

(use "(use-package " p ")")
(lambda "(lambda (" p ")" n> r> ")")
(autoload ";;;###autoload")
(pt "(point)")
(var "(defvar " p "\n  \"" p "\")")
(local "(defvar-local " p "\n  \"" p "\")")
(const "(defconst " p "\n  \"" p "\")")
(custom "(defcustom " p "\n  \"" p "\"" n> ":type '" p ")")
(face "(defface " p " '((t :inherit " p "))\n  \"" p "\")")
(group "(defgroup " p " nil\n  \"" p "\"" n> ":group '" p n> ":prefix \"" p "-\")")
(macro "(defmacro " p " (" p ")\n  \"" p "\"" n> r> ")")
(alias "(defalias '" p " '" p ")")
(fun "(defun " p " (" p ")\n  \"" p "\"" n> r> ")")
(iflet "(if-let* (" p ")" n> r> ")")
(whenlet "(when-let* (" p ")" n> r> ")")
(whilelet "(while-let (" p ")" n> r> ")")
(andlet "(and-let* (" p ")" n> r> ")")
(cond "(cond (" p ")" n> "()" n> "()" ")")
(pcase "(pcase " (p "scrutinee") n "(" q "))" >)
(let "(let (" p ")" n> r> ")")
(lett "(let* (" p ")" n> r> ")")
(pcaselet "(pcase-let (" p ")" n> r> ")")
(pcaselett "(pcase-let* (" p ")" n> r> ")")
(rec "(letrec (" p ")" n> r> ")")
(dotimes "(dotimes (" p ")" n> r> ")")
(dolist "(dolist (" p ")" n> r> ")")
(loop "(cl-loop for " p " in " p " do" n> r> ")")
(command "(defun " p " (" p ")\n  \"" p "\"" n> "(interactive" p ")" n> r> ")")
(header ";;; " (file-name-nondirectory (or (buffer-file-name) (buffer-name)))
        " --- " p " -*- lexical-binding: t -*-" n
        ";;; Commentary:" n ";;; Code:" n n)
(provide "(provide '" (file-name-base (or (buffer-file-name) (buffer-name))) ")" n
         ";;; " (file-name-nondirectory (or (buffer-file-name) (buffer-name)))
         " ends here" n)
(package (i header) r n n (i provide))

eshell-mode

(for "for " (p "i") " in " p " { " q " }")
(while "while { " p " } { " q " }")
(until "until { " p " } { " q " }")
(if "if { " p " } { " q " }")
(ife "if { " p " } { " p " } { " q " }")
(unl "unless { " p " } { " q " }")
(unle "unless { " p " } { " p " } { " q " }")

text-mode

(box "┌─" (make-string (length str) ?─) "─┐" n
     "│ " (s str)                       " │" n
     "└─" (make-string (length str) ?─) "─┘" n)
(abox "+-" (make-string (length str) ?-) "-+" n
      "| " (s str)                       " |" n
      "+-" (make-string (length str) ?-) "-+" n)
(cut "--8<---------------cut here---------------start------------->8---" n r n
     "--8<---------------cut here---------------end--------------->8---" n)
(rot13 (p "plain text" text) n "----" n (rot13 text))
(calc (p "taylor(sin(x),x=0,3)" formula) n "----" n (format "%s" (calc-eval formula)))
(table (p (read-number "Rows: ") rows noinsert)
       (p (read-number "Cols: ") cols noinsert)
       "| " (p "  ") (* (1- cols) " | " (p "  ")) " |" n
       "|" (* cols "----|") n
       (* rows "| " (p "  ") (* (1- cols) " | " (p "  ")) " |" n))

rst-mode

(title (make-string (length title) ?=) n (p "Title: " title) n (make-string (length title) ?=) n)

c-mode :when (re-search-backward "^\\S-*$" (line-beginning-position) 'noerror)

(inc "#include <" (p (concat (file-name-base (or (buffer-file-name) (buffer-name))) ".h")) ">")
(incc "#include \"" (p (concat (file-name-base (or (buffer-file-name) (buffer-name))) ".h")) "\"")

org-mode :when (and (org-in-src-block-p)
                    (string= (org-element-property :language (org-element-context))
                             "emacs-lisp"))

(use "(use-package " p ")")
(lambda "(lambda (" p ")" n> r> ")")
(autoload ";;;###autoload")

org-mode

(caption "#+caption: ")
(drawer ":" p ":" n r ":end:")
(begin "#+begin_" (s name) n> r> n "#+end_" name)
(quote "#+begin_quote" n> r> n "#+end_quote")
(sidenote "#+begin_sidenote" n> r> n "#+end_sidenote")
(marginnote "#+begin_marginnote" n> r> n "#+end_marginnote")
(example "#+begin_example" n> r> n "#+end_example")
(center "#+begin_center" n> r> n "#+end_center")
(ascii "#+begin_export ascii" n> r> n "#+end_export")
(html "#+begin_export html" n> r> n "#+end_export")
(latex "#+begin_export latex" n> r> n "#+end_export")
(comment "#+begin_comment" n> r> n "#+end_comment")
(verse "#+begin_verse" n> r> n "#+end_verse")
(src "#+begin_src " q n r n "#+end_src")
(gnuplot "#+begin_src gnuplot :var data=" (p "table") " :file " (p "plot.png") n r n "#+end_src" :post (org-edit-src-code))
(elisp "#+begin_src emacs-lisp" n r n "#+end_src" :post (org-edit-src-code))
(inlsrc "src_" p "{" q "}")
(title "#+title: " p n "#+author: Alex Lu" n "#+language: en")

;; Local Variables:
;; mode: lisp-data
;; outline-regexp: "[a-z]"
;; End:
#+end_src

* File management
:PROPERTIES:
:CUSTOM_ID: h:2F4217E3-BF28-4F5D-B8F6-389562DF634A
:END:

** File/Directory handling functions (files.el)
:PROPERTIES:
:CUSTOM_ID: h:79DC4C05-4541-498C-918D-5769455C429C
:END:

+ Save modified buffers automatically
+ Utilities:
  - ~+files-find-dotfiles~
  - ~+files-edit-grandview-config~
  - ~+files-sudo-find~
  - ~+files-rename-file-and-buffer~
  - ~+files-find-user-files~

#+begin_src emacs-lisp
(use-package files :ensure nil)

(setq large-file-warning-threshold 50000000)
(setq permanently-enabled-local-variables '(lexical-binding encoding))
(setq +files-user-dirs-alist
      '(((title . "  Share")        (path . "/mnt/HDD/Share"))
        ((title . "  Coding")       (path . "/mnt/HDD/Dev"))
        ((title . "󰂺  Books")        (path . "/mnt/HDD/Book"))
        ((title . "  Videos")       (path . "/mnt/HDD/Video"))
        ((title . "  Notes")        (path . "~/Documents/notes"))
        ((title . "  Photos")       (path . "~/Pictures"))
        ((title . "  Downloads")    (path . "~/Downloads"))))
(setq confirm-kill-processes nil)

(with-eval-after-load 'meow ;; files usually edited in `meow-insert-mode'
  (setq auto-save-default nil)
  (auto-save-visited-mode)
  (setopt auto-save-visited-interval 300))

(define-key grandview-file-map (kbd "w") 'save-buffer) ; [SPC x s] in Colemak is painful to press
(define-key grandview-file-map (kbd "g") '+files-edit-grandview-config)
(define-key grandview-file-map (kbd ".") '+files-find-dotfiles)
(define-key grandview-file-map (kbd "s") '+files-sudo-find)
(define-key grandview-file-map (kbd "r") '+files-rename-file-and-buffer)
(define-key grandview-file-map (kbd "u") '+files-find-user-files)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:89CC46D7-7265-4442-BBFE-6627EFE1EB9C
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+files.el"
:END:

#+begin_src emacs-lisp
(defcustom +files-dotfiles-repo "/opt/dotfiles/"
  "Path for user dotfiles."
  :group 'grandview :type 'string)

(defcustom +files-user-dirs-alist
  '(((title . "  Photos")       (path . "~/Pictures/"))
    ((title . "  Videos")       (path . "~/Video/"))
    ((title . "  Downloads")    (path . "~/Downloads/")))
  "Doc."
  :group 'grandview :type '(repeat list))

(defun +files--in-directory (dir &optional prompt)
  "Use `fd' to list files in DIR."
  (let* ((default-directory dir)
         (command "fd -H -t f -0")
         (output (shell-command-to-string command))
         (files-raw (split-string output "\0" t))
         (files (+minibuffer-append-metadata 'file files-raw))
         (file (completing-read (or prompt "Open file: ") files)))
    (find-file (concat dir "/" file))))

;;;###autoload
(defun +files-edit-grandview-config ()
  "Edit grandview's org file."
  (interactive)
  (find-file grandview--dot-org))

;;;###autoload
(defun +files-rename-file-and-buffer (name)
  "Apply NAME to current file and rename its buffer.
Do not try to make a new directory or anything fancy."
  (interactive
   (list (read-string "Rename current file: " (buffer-file-name))))
  (let* ((file (buffer-file-name)))
    (if (vc-registered file)
        (vc-rename-file file name)
      (rename-file file name))
    (set-visited-file-name name t t)))

;;;###autoload
(defun +files-find-dotfiles ()
  "Open files in dotfiles repo."
  (interactive)
  (unless +files-dotfiles-repo
    (user-error "`+files-dotfiles-repo' is undefined"))
  (+files--in-directory +files-dotfiles-repo " Dotfiles: "))

;;;###autoload
(defun +files-sudo-find ()
  "Reopen current file as root."
  (interactive)
  (let ((file (buffer-file-name)))
    (find-file (if (file-writable-p file)
                   file
                 (concat "/sudo::" file)))))

;;;###autoload
(defun +files-find-user-files ()
  "Open files in directories defined in `+files-user-dirs-alist'."
  (interactive)
  (let* ((cands-raw
          (mapcar (lambda (i) (cdr (assq 'title i))) +files-user-dirs-alist))
         (get-item (lambda (s field)
                     (cl-dolist (i +files-user-dirs-alist)
                       (when (string= s (cdr (assq 'title i)))
                         (cl-return (cdr (assq field i)))))))
         (annotation
          (lambda (s) (marginalia--documentation (funcall get-item s 'path))))
         (cands (+minibuffer-append-metadata annotation cands-raw))
         (title (completing-read "Open: " cands nil t))
         (path (funcall get-item title 'path)))
    (+files--in-directory path (concat title ": "))))
#+end_src

** Find libraries (find-func.el)
:PROPERTIES:
:CUSTOM_ID: h:386D803D-CA14-4ACE-A7A6-F5B137E7C353
:END:

This packages provides the ~find-library~ command which allows us browsing the
source code of Emacs efficiently, want to have to look on =dired.el=? Just ~M-x
find-library RET dired~. Even better, we can introspect the C code of Emwacs
itself as long as the ~find-function-C-source-directory~ is set properly.

#+begin_src emacs-lisp
(use-package find-func :ensure t :after-call minibuffer-setup-hook)

(define-key grandview-file-map (kbd "l") 'find-library)

(when (eq system-type 'gnu/linux)
  (setq find-function-C-source-directory "~/Code/emacs/src"))
#+end_src

** Recent files (recentf.el)
:PROPERTIES:
:CUSTOM_ID: h:9500079C-EA85-46E9-A8E3-084F611A4DDA
:END:

*recentf.el* keep a record of recently opened files.

The =recentf-cleanup= command, as its name suggest, cleans up the recent files
list.  That is, remove duplicates, non-kept, and excluded files.  In order to
keep our recent file list always up-to-date, running it once whenever the mode
is activate, which is the default behavior, is not enough.  Hence, we set it to
do the cleaning task every 5 minutes.

#+begin_src emacs-lisp
(use-package recentf :ensure nil :after-call meow-keypad-mode-hook)

(with-eval-after-load 'recentf
  (setq recentf-max-saved-items 300)
  (setq recentf-auto-cleanup 300)
  (recentf-mode 1))
#+end_src

** Restore file place (saveplace.el)
:PROPERTIES:
:CUSTOM_ID: h:0963A7D0-58A0-428E-9277-7296E80C43EE
:END:

Just remember where the point is in any given file.  This can often
be a subtle reminder of what you were doing the last time you
visited that file, allowing you to pick up from there.

#+begin_src emacs-lisp
(use-package saveplace :ensure nil :after-call find-file-hook)

(with-eval-after-load 'saveplace
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

** Auto refresh file content (autorevert.el)
:PROPERTIES:
:CUSTOM_ID: h:0F47CCEA-83F8-4A20-A7FA-E6EB7478ED57
:END:

This mode ensures that the buffer is updated whenever the file
changes.  A change can happen externally or by some other tool
inside of Emacs (e.g. kill a Magit diff).

#+begin_src emacs-lisp
(use-package autorevert :ensure nil :after-call after-find-file)

(with-eval-after-load 'autorevert
  (setq auto-revert-verbose t)
  (global-auto-revert-mode))
#+end_src

** Dired (dired.el)
:PROPERTIES:
:CUSTOM_ID: h:6A72D4DB-61C0-418E-98C2-56FE0DB68E91
:END:

=Dired= is a built-in tool that performs file management operations
inside of an Emacs buffer.  It is simply superb!

#+begin_src emacs-lisp
(use-package dired :ensure nil :after-call pre-command-hook)
(use-package dired-x :ensure nil)
(use-package dired-aux :ensure nil)
(use-package diredfl :ensure t)

(with-eval-after-load 'diredfl
  (set-face-attribute 'diredfl-dir-name nil :bold t)
  (add-hook 'enable-theme-functions
            (lambda (_theme)
              (set-face-attribute 'diredfl-dir-name nil :bold t))))

(when (eq system-type 'darwin) (setq insert-directory-program "gls"))
(setq dired-listing-switches
      "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group")

(with-eval-after-load 'dired
  (add-hook 'dired-mode-hook 'diredfl-mode)
  (setq mouse-1-click-follows-link nil)
  (setq dired-mouse-drag-files t)                   ; added in Emacs 29
  (setq mouse-drag-and-drop-region-cross-program t) ; added in Emacs 29
  (setq dired-kill-when-opening-new-dired-buffer t) ; added in Emacs 28
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-bind-info nil)
  (setq dired-bind-man nil)
  (setq dired-clean-confirm-killing-deleted-buffers nil)
  (setq dired-do-revert-buffer t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p)
  (define-key dired-mode-map (kbd "/") 'dired-goto-file)
  (define-key dired-mode-map (kbd ",") 'dired-create-directory)
  (define-key dired-mode-map (kbd ".") 'dired-create-empty-file)
  (define-key dired-mode-map (kbd "I") 'dired-insert-subdir)
  (define-key dired-mode-map (kbd "K") 'dired-kill-subdir)
  (define-key dired-mode-map (kbd "O") 'dired-find-file-other-window)
  (define-key dired-mode-map (kbd "[") 'dired-prev-dirline)
  (define-key dired-mode-map (kbd "]") 'dired-next-dirline)
  (define-key dired-mode-map (kbd "o") 'dired-up-directory)
  (define-key dired-mode-map (kbd "^") 'mode-line-other-buffer)
  (define-key dired-mode-map (kbd "x") 'dired-do-delete)
  (define-key dired-mode-map (kbd "X") 'dired-do-flagged-delete)
  (define-key dired-mode-map (kbd "y") 'dired-do-copy))

(with-eval-after-load 'dired-x
  (setq dired-omit-files (concat dired-omit-files "\\|^\\..*$")))
#+end_src

** Writable Dired (wdired.el)
:PROPERTIES:
:CUSTOM_ID: h:39A09526-7F38-4DA8-BE81-DC02D32FDC58
:END:

Bulk renaming files like a breeze.

#+begin_src emacs-lisp
(use-package wdired :ensure nil)

(with-eval-after-load 'dired
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t)
  (define-key dired-mode-map (kbd "i") 'wdired-change-to-wdired-mode))
#+end_src

** Use dired to browse and manipulate images (image-dired.el)
:PROPERTIES:
:CUSTOM_ID: h:398861A3-9FBA-43EA-A54F-3C06C4902C7D
:END:


=image-dired= allows us to browse and manipulate images using Dired.

+ show bigger sized thumbnail image, we are in the 21st century
+ no not display original image in other window when flag/mark files
  - it's very slow
  - if I want to view the bigger image, I use =dirvish= instead
+ tweak the keybindings to my preferences

#+begin_src emacs-lisp
(use-package image-dired :ensure nil)

(with-eval-after-load 'image-dired
  (setq image-dired-thumb-size 256)
  (setq image-dired-marking-shows-next nil)
  (define-key image-dired-thumbnail-mode-map (kbd "n") 'image-dired-next-line)
  (define-key image-dired-thumbnail-mode-map (kbd "p") 'image-dired-previous-line)
  (define-key image-dired-thumbnail-mode-map (kbd "i") 'image-dired-forward-image)
  (define-key image-dired-thumbnail-mode-map (kbd "o") 'image-dired-backward-image))
#+end_src

** A polished dired with batteries included (dirvish.el)
:PROPERTIES:
:CUSTOM_ID: h:AAFF178E-C115-4A55-8B8F-BE287515CDCE
:END:

This package empowers dired by giving it a modern UI in a unintrusive way. Emacs
users deserve a file manager better than those popular ones on terminal such as
[[https://github.com/ranger/ranger][ranger]], [[https://github.com/vifm/vifm][vifm]], [[https://github.com/gokcehan/lf][lf]] since Emacs is more than a terminal emulator.

The usage of =:vc= in the =use-package= declaration and the implict =require=
statement is for the purpose of maintaining this project, you don't have to do
that if you install it from Melpa.

#+begin_src emacs-lisp
;; (use-package dirvish :ensure t) ; for normal user, install from Melpa
(use-package dirvish
  :load-path "~/.cache/emacs/elpa/dirvish"
  :vc (:url "https://github.com/alexluigit/dirvish" :lisp-dir "extensions")
  :after-call meow-keypad-mode-hook)

(with-eval-after-load 'dirvish
  (require 'dirvish-extras)
  (dirvish-override-dired-mode)
  (dirvish-side-follow-mode) ;; `project-current' is buggy in Emacs 31
  (dirvish-peek-mode)
  (add-hook 'dirvish-setup-hook 'dirvish-emerge-mode)
  (add-hook 'dirvish-directory-view-mode-hook 'diredfl-mode)
  (setq dirvish-attributes
        '(vc-state file-size git-msg subtree-state nerd-icons collapse file-time))
  (setopt dirvish-subtree-state-style 'nerd)
  (setq dirvish-mode-line-format '(:left (sort symlink) :right (vc-info yank index)))
  (setq dirvish-header-line-height '(25 . 35))
  (setq dirvish-mode-line-height 21)
  (setq dirvish-side-width 38)
  (setq dirvish-header-line-format '(:left (path) :right (free-space)))
  (setq dirvish-path-separators (list "  " "  " "  "))
  (appendq! dirvish-preview-disabled-exts '("lockb" "sqlite" "db"))
  (setopt dirvish-quick-access-entries
          '(("o" "~/"                          "Home")
            ("d" "/opt/dotfiles/"              "Dotfiles")
            ("u" "~/.cache/emacs/"             "Emacs cache")
            ("p" "~/Code/"                     "Code")
            ("n" "~/Downloads/"                "Downloads")
            ("w" "~/Pictures/wallpaper/"       "Wallpaper")
            ("m" "/mnt/"                       "Mounted Drives")
            ("s" "/mnt/HDD/Share/"             "Shared files")
            ("a" "🔍\\\.org$📁~/Documents/📁" "AllNotes")
            ("t" "~/.local/share/Trash/files/" "Trash")
            ("W"  "/smb:alex%192.168.0.177@192.168.0.177:share/")))
  (define-key dirvish-mode-map (kbd "<mouse-1>") 'dirvish-subtree-toggle-or-open)     ; left click for expand/collapse dir or open file
  (define-key dirvish-mode-map (kbd "<mouse-2>") 'dired-mouse-find-file-other-window) ; middle click for opening file / entering dir in other window
  (define-key dirvish-mode-map (kbd "<mouse-3>") 'dired-mouse-find-file)              ; right click for opening file / entering dir
  (define-key dirvish-mode-map (kbd "<mouse-8>") 'dired-do-shell-command)             ; side button for shell command execution
  (define-key dirvish-mode-map (kbd "SPC") 'consult-buffer)
  (define-key dirvish-mode-map (kbd "s-n") 'dirvish-history-go-forward)
  (define-key dirvish-mode-map (kbd "s-p") 'dirvish-history-go-backward)
  (define-key dirvish-mode-map (kbd "h") 'dirvish-history-jump)
  (define-key dirvish-mode-map (kbd "^") 'dirvish-history-last)
  (define-key dirvish-mode-map (kbd "TAB") 'dirvish-subtree-toggle)
  (define-key dirvish-mode-map (kbd "a") 'dirvish-quick-access)
  (define-key dirvish-mode-map (kbd "f") 'dirvish-file-info-menu)
  (define-key dirvish-mode-map (kbd "v") 'dirvish-vc-menu)
  (define-key dirvish-mode-map (kbd "*") 'dirvish-mark-menu)
  (define-key dirvish-mode-map (kbd "N") 'dirvish-narrow)
  (define-key dirvish-mode-map (kbd "s-e") 'dirvish-emerge-menu)
  (define-key dirvish-mode-map (kbd "s-t") 'dirvish-layout-toggle)
  (define-key dirvish-mode-map (kbd "s-s") 'dirvish-setup-menu)
  (define-key dirvish-mode-map (kbd "s-j") 'dirvish-fd-jump)
  (define-key dirvish-mode-map [remap dired-sort-toggle-or-edit] 'dirvish-quicksort)
  (define-key dirvish-mode-map [remap dired-do-redisplay] 'dirvish-ls-switches-menu)
  (define-key dirvish-mode-map [remap dired-do-copy] 'dirvish-yank-menu)
  (define-key mode-specific-map (kbd "e") 'dirvish-dwim)
  (define-key grandview-file-map (kbd "e") 'dirvish)
  (define-key grandview-file-map (kbd "f") 'dirvish-fd)
  (define-key grandview-file-map (kbd "n") 'dirvish-side)
  (define-key grandview-file-map (kbd "o") 'dirvish-quick-access)
  (define-key grandview-file-map (kbd "b") 'dirvish-fd-jump))
#+end_src

** Project management (project.el)
:PROPERTIES:
:CUSTOM_ID: h:29675BEC-05AD-4591-8D74-B7284820D7FC
:END:

#+begin_src emacs-lisp
(use-package project :ensure nil)

(setq project-switch-commands
      '((project-find-file "File" ?\r)
        (+project-find-subdir "Subdir" ?s)
        (project-dired "Dired" ?d)
        (+project-retrieve-tag "Tag switch" ?t)
        (+project-magit-status "Magit" ?m)
        (+project-commit-log "Log VC" ?l)))
(setq +project-commit-log-limit 25)

(define-key 'grandview-project-map (kbd "l") '+project-commit-log)
(define-key 'grandview-project-map (kbd "m") '+project-magit-status)
(define-key 'grandview-project-map (kbd "s") '+project-find-subdir)
(define-key 'grandview-project-map (kbd "t") '+project-retrieve-tag)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:0C70EF8E-00DB-4201-8110-83FD08E51D68
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+project.el"
:END:

#+begin_src emacs-lisp
(require 'cl-lib)
(require 'project)
(require 'vc)

(defcustom +project-commit-log-limit 25
  "Limit commit logs for project to N entries by default.
A value of 0 means 'unlimited'."
  :type 'integer
  :group 'ale)

;;;###autoload
(cl-defmethod project-root ((project (head local)))
  "Project root for PROJECT with HEAD and LOCAL."
  (if (< emacs-major-version 29)
      (cdr-safe project)
    (car (project-roots project))))

;; Copied from Manuel Uberti and tweaked accordingly:
;; <https://www.manueluberti.eu/emacs/2020/11/14/extending-project/>.
(defun +project--project-files-in-directory (dir)
  "Use `fd' to list files in DIR."
  (unless (executable-find "fd")
    (error "Cannot find 'fd' command is shell environment $PATH"))
  (let* ((default-directory dir)
         (localdir (file-local-name (expand-file-name dir)))
         (command (format "fd -t f -H -0 . %s" localdir)))
    (project--remote-file-names
     (split-string (shell-command-to-string command) "\0" t))))

(cl-defmethod project-files ((project (head vc)) &optional dirs)
  "Override `project-files' to use `fd' in local projects.
Project root for PROJECT with HEAD and VC, plus optional
DIRS."
  (mapcan #'+project--project-files-in-directory
          (or dirs (list (project-root project)))))

(defun +project--directory-subdirs (dir)
  "Return list of subdirectories in DIR."
  (cl-remove-if (lambda (x) (string-match-p "\\.git" x))
                (cl-remove-if-not (lambda (x) (file-directory-p x))
                                  (directory-files-recursively dir ".*" t t))))

;;;###autoload
(defun +project-find-subdir ()
  "Find subdirectories in the current project, using completion."
  (interactive)
  (let* ((pr (project-current t))
         (dir (project-root pr))
         (dirs-raw (+project--directory-subdirs dir))
         (subdirs (+minibuffer-append-metadata 'file dirs-raw))
         (directory (completing-read "Select Project subdir: " subdirs)))
    (dired directory)))

;;;###autoload
(defun +project-commit-log (&optional arg)
  "Print commit log for the current project.
With optional prefix ARG (\\[universal-argument]) shows expanded
commit messages and corresponding diffs.

The log is limited to the integer specified by
`+project-commit-log-limit'.  A value of 0 means
'unlimited'."
  (interactive "P")
  (let* ((pr (project-current t))
         (dir (cdr pr))
         (default-directory dir) ; otherwise fails at spontaneous M-x calls
         (backend (vc-responsible-backend dir))
         (num +project-commit-log-limit)
         (int (if (numberp num) num (error "%s is not a number" n)))
         (limit (if (= int 0) t int))
         (diffs (if arg 'with-diff nil))
         (vc-log-short-style (unless diffs '(directory))))
    (vc-print-log-internal backend (list dir) nil nil limit diffs)))

;;;###autoload
(defun +project-retrieve-tag ()
  "Run `vc-retrieve-tag' on project and switch to the root dir.
Basically switches to a new branch or tag."
  (interactive)
  (let* ((pr (project-current t))
         (dir (cdr pr))
         (default-directory dir) ; otherwise fails at spontaneous M-x calls
         (name
          (vc-read-revision "Tag name: "
                            (list dir)
                            (vc-responsible-backend dir))))
    (vc-retrieve-tag dir name)
    (project-dired)))

(autoload 'magit-status "magit")

;;;###autoload
(defun +project-magit-status ()
  "Run `magit-status' on project."
  (interactive)
  (let* ((pr (project-current t))
         (dir (project-root pr)))
    (magit-status dir)))

;;;###autoload
(defun +project-find-file (&optional force)
  "Same as `project-find-file' except using magit for project
choosing.
With a universal prefix to choose project anyway."
  (interactive "P")
  (if (or force (null (project-current)))
      (let ((current-prefix-arg '(4))
            (display-buffer-alist '(("magit: .*" (display-buffer-same-window)))))
        (call-interactively 'magit-status))
    (project-find-file)))
#+end_src

** Working with remote files (tramp.el)
:PROPERTIES:
:CUSTOM_ID: h:04FB6C89-69E6-416F-BE7D-916308165779
:END:

#+begin_src emacs-lisp
(use-package tramp :ensure nil)

(with-eval-after-load 'tramp
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/ssh:buzz:") "direct-async-process" t))
  (setq tramp-verbose 0)
  (setq tramp-auto-save-directory (locate-user-emacs-file "tramp/"))
  (setq tramp-chunksize 2000)
  (setopt tramp-use-ssh-controlmaster-options nil))
#+end_src

* Text editing
:PROPERTIES:
:CUSTOM_ID: h:401D8E76-D334-4E49-A670-8F04B6EA5B27
:END:

** Long line text (so-long.el)
:PROPERTIES:
:CUSTOM_ID: h:F19F714D-1B7B-47A1-AE22-5DF737822996
:END:

Consistent performance is the reason to enable =global-so-long-mode=, built into
Emacs versions >= 27, which allows the active major mode to gracefully adapt to
buffers with very long lines. What “very long” means is, of course,
configurable: M-x find-library so-long covers several customisation options,
though I find that the defaults require no further intervention from my part.

=so-long-mode= Files with long lines have huge performance impact for file preview
(in our case =dirvish.el=), so we ensure the =global-so-long-mode= is enabled before
=dirvish= is loaded.

#+begin_src emacs-lisp
(use-package so-long :ensure nil :after-call dired-mode-hook)

(with-eval-after-load 'so-long (global-so-long-mode))
#+end_src

** Fill line (fill.el)
:PROPERTIES:
:CUSTOM_ID: h:065A996E-9860-46BE-BC54-B12EC8414752
:END:

The =fill.el= library is a tiny wrapper around some Emacs settings and modes that
are scrattered around several files, which control (i) how paragraphs or
comments in programming modes should be wrapped to a given column count, and
(ii) what constitutes a sentence. Although ~fill-column~ variable is not defined
in =fill.el=, I believe put them all together here make things easier to track.

With regard to paragraphs, I find that a double space is the best way to delimit
sentences in source form, where a monospaced typeface is customary. There is no
worry that this will be shown on a website or rendered version of a document,
because processors know how to handle spacing. We do this to make phrases easier
to tell apart, but also to render unambiguous commands like forward-sentence.

#+begin_src emacs-lisp
(use-package fill :ensure nil)

(add-hook 'text-mode-hook 'turn-on-auto-fill)

(setq-default fill-column 80)
(setq colon-double-space nil)
(setq adaptive-fill-mode t)
(setq sentence-end-double-space t)
(setq sentence-end-without-period nil)
#+end_src

** Cross reference (xref.el)
:PROPERTIES:
:CUSTOM_ID: h:9409CEEF-F5E0-46FF-9AF0-1159A5778FE1
:END:

*xref* is a pluggable emacs subsystem to quickly find where identifiers are
defined and referenced, and for quick renaming, etc.

Every module (such as *eglot*) that plugs into xref must provide a constructor function that
returns a backend value and a set of methods:

- ~xref-backend-identifier-at-point~
- ~xref-backend-identifier-completion-table~
- ~xref-backend-definitions~
- ~xref-backend-references~
- ~xref-backend-apropos~

For users, there are some commands that are available to users by default, the
most frequently used are:

- ~xref-find-definitions~ (=M-.=)
- ~xref-go-back~ (=M-,=)
- ~xref-find-references~ (=M-?=)
- ...etc.

#+begin_src emacs-lisp
(use-package xref :ensure nil)

(setq xref-file-name-display 'project-relative)
(setq xref-search-program 'ripgrep)
#+end_src

** Interactive diff, patch, or merge conflict (ediff.el)
:PROPERTIES:
:CUSTOM_ID: h:C990DF9D-D266-4514-A1B6-B86F262036CA
:END:

This package provides a convenient way of simultaneous browsing through the
differences between a pair (or a triple) of files or buffers.  The files being
compared, file-A, file-B, and file-C (if applicable) are shown in separate
windows (side by side, one above the another, or in separate frames), and the
differences are highlighted as you step through them.  You can also copy
difference regions from one buffer to another (and recover old differences if
you change your mind).

#+begin_src emacs-lisp
(use-package ediff :ensure nil)

(setq ediff-keep-variants nil)
(setq ediff-make-buffers-readonly-at-startup nil)
(setq ediff-merge-revisions-with-ancestor t)
(setq ediff-show-clashes-only t)
(setq ediff-split-window-function 'split-window-horizontally)
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
;; Tweak those for safer identification and removal
(setq ediff-combination-pattern
      '("<<<<<<< grandv-ediff-combine Variant A" A
        ">>>>>>> grandv-ediff-combine Variant B" B
        "####### grandv-ediff-combine Ancestor" Ancestor
        "======= grandv-ediff-combine End"))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:36712AF7-6246-43B1-9F42-ACE9A0FD3ED9
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+ediff.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +ediff-flush-combination-pattern ()
  "Remove my custom `ediff-combination-pattern' markers.
This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
  (interactive)
  (flush-lines ".*grandv-ediff.*" (point-min) (point-max) nil))
#+end_src

** Input method (rime.el)
:PROPERTIES:
:CUSTOM_ID: h:D97101B7-E8EB-4C7B-B097-E1E2ADCF72F9
:END:

#+begin_src emacs-lisp
(use-package rime :ensure t)

(setq default-input-method "rime")
(with-eval-after-load 'rime
  (when (eq system-type 'darwin)
    (setq rime-librime-root (expand-file-name "librime" user-emacs-directory))
    (setq rime-emacs-module-header-root "/opt/homebrew/include"))
  (setq rime-disable-predicates '(meow-normal-mode-p
                                  meow-motion-mode-p
                                  meow-keypad-mode-p
                                  rime-predicate-after-alphabet-char-p))
  (setq rime-inline-predicates '(rime-predicate-space-after-cc-p
                                 rime-predicate-current-uppercase-letter-p))
  (setq rime-show-candidate 'posframe)
  (setq rime-posframe-style 'vertical)
  (setq rime-posframe-properties '(:internal-border-width 10 :lines-truncate t))
  (setq rime-title "ㄓ")
  (setq rime-candidate-num-format-function #'+rime-candidate-num-fmt)
  (custom-theme-set-faces
   'user '(rime-preedit-face ((t (:inherit lazy-highlight)))))
  (define-key rime-active-mode-map (kbd "C-`") 'rime-send-keybinding)
  (define-key rime-active-mode-map (kbd "C-k") 'rime-send-keybinding)
  (define-key rime-active-mode-map (kbd "<C-i>") 'rime-send-keybinding)
  (define-key rime-active-mode-map (kbd "C-o") 'rime-send-keybinding)
  (define-key rime-active-mode-map (kbd "C-a") 'rime-send-keybinding)
  (define-key rime-active-mode-map (kbd "C-e") 'rime-send-keybinding)
  (define-key rime-active-mode-map (kbd "<escape>") (lambda () (interactive) (execute-kbd-macro (kbd "C-g"))))
  (define-key rime-active-mode-map (kbd [tab]) 'rime-send-keybinding))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:6B8B3E46-1951-4840-B3B3-4667AD69C2FA
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+rime.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defadvice! rime-return-a (fn &rest args)
  "Make return key (commit script text) compatible with vterm."
  :around #'rime-return
  (interactive)
  (if (eq major-mode 'vterm-mode)
      (progn
        (let ((input (rime-lib-get-input)))
          (execute-kbd-macro (kbd "<escape>"))
          (toggle-input-method)
          (dotimes (i (length input))
            (execute-kbd-macro (kbd (substring input i (+ i 1)))))
          (toggle-input-method)))
    (apply fn args)))

;;;###autoload
(defun +rime-candidate-num-fmt (num select-labels)
  "Format for the number before each candidate."
  (if select-labels
      (format "%s " (nth (1- num) select-labels))
    (format "%d. " num)))
#+end_src

** Pair insertion (eletric.el)
:PROPERTIES:
:CUSTOM_ID: h:CF2FA7CE-78D4-4941-B286-F1062994900C
:END:

Emacs labels as =electric= any behaviour that involves contextual auto-insertion
of characters.

- Indent automatically.

- If =electric-pair-mode= is enabled (which I might do manually),
  insert quotes and brackets in pairs.  Only do so if there is no
  alphabetic character after the cursor.

- To get those numbers, evaluate =(string-to-char CHAR)= where CHAR
  is the one you are interested in.  For example, get the literal
  tab's character with `(string-to-char "\t")'.

- While inputting a pair, inserting the closing character will just
  skip over the existing one, rather than add a new one.

- Do not skip over whitespace when operating on pairs.  Combined
  with the above point, this means that a new character will be
  inserted, rather than be skipped over.  I find this better,
  because it prevents the point from jumping forward, plus it
  allows for more natural editing.

- The rest concern the conditions for transforming quotes into
  their curly equivalents.  I keep this disabled, because curly
  quotes are distinct characters.  It is difficult to search for
  them.  Just note that on GNU/Linux you can type them directly by
  hitting the "compose" key and then an angled bracket (=<= or =>=)
  followed by a quote mark.

#+begin_src emacs-lisp
(use-package electric :ensure nil)

(add-hook 'org-mode-hook '+electric-inhibit-<)
(add-hook 'minibuffer-setup-hook
          (lambda () (unless (eq this-command 'eval-expression)
                       (electric-pair-mode 0))))
(add-hook 'minibuffer-exit-hook (lambda () (electric-pair-mode 1)))

(setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
(setq electric-pair-preserve-balance t)
(setq electric-pair-pairs
      '((8216 . 8217)
        (8220 . 8221)
        (171 . 187)))
(setq electric-pair-skip-self 'electric-pair-default-skip-self)
(setq electric-pair-skip-whitespace nil)
(setq electric-pair-skip-whitespace-chars '(9 10 32))
(setq electric-quote-context-sensitive t)
(setq electric-quote-paragraph t)
(setq electric-quote-string nil)
(setq electric-quote-replace-double t)
(electric-indent-mode 1)
(electric-pair-mode 1)
(electric-quote-mode -1)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:AED70F01-7494-4652-B763-76FA41DF7902
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+eletric.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defadvice! electric-pair-post-self-insert-a (fn &rest args)
  "Doc."
  :around #'electric-pair-post-self-insert-function
  (let ((mark-active nil)) (apply fn args)))

;;;###autoload
(defun +electric-inhibit-< ()
  (setq-local electric-pair-inhibit-predicate
              `(lambda (c)
                 (if (char-equal c ?<) t
                   (,electric-pair-inhibit-predicate c)))))
#+end_src

** Parentheses (paren.el / rainbow-delimiters.el)
:PROPERTIES:
:CUSTOM_ID: h:6443408B-A49C-4D29-B14F-998CDB289F76
:END:

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.
- Use rainbow color for delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters :ensure t)

(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

(setq show-paren-style 'parenthesis)
(setq show-paren-when-point-in-periphery nil)
(setq show-paren-when-point-inside-paren nil)
(show-paren-mode)
#+end_src

** Prettify symbols (prog-mode.el)
:PROPERTIES:
:CUSTOM_ID: h:C5B6527C-E772-40DA-9142-F0AACA0B2AB9
:END:

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'prettify-symbols-mode)

(setq-default prettify-symbols-alist
              '(("<-" . ?←)
                ("->" . ?→)
                ("->>" . ?↠)
                ("=>" . ?⇒)
                ("/=" . ?≠)
                ("!=" . ?≠)
                ("==" . ?≡)
                ("<=" . ?≤)
                (">=" . ?≥)
                ("=<<" . (?= (Br . Bl) ?≪))
                (">>=" . (?≫ (Br . Bl) ?=))
                ("<=<" . ?↢)
                (">=>" . ?↣)))
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+end_src

* Org mode
:PROPERTIES:
:CUSTOM_ID: h:D30BE4AD-1214-42E5-8634-A76D5CF5F9E7
:END:

** Org (org.el)
:PROPERTIES:
:CUSTOM_ID: h:4EDF19C6-565A-4AD5-937E-E8749F4C1129
:END:

In its purest form, Org is a markup language that is similar to Markdown:
symbols are used to denote the meaning of a construct in its context, such as
what may represent a headline element or a phrase that calls for emphasis.

What lends Org its super powers though is everything else built around it: a
rich corpus of Elisp functions that automate, link, combine, enhance, structure,
or otherwise enrich the process of using this rather straightforward system of
plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and workflows
on how to organise one's life with plain text.

This section is all about basic configurations for how does a =.org= file should
look like which can be described briefly as follows:

+ use bigger fonts for different levels of heading
+ show ellipsis marker when a node is folded
+ center text when make sense
+ indent text according to outline structure
+ display inline images in url automatically

#+begin_src emacs-lisp
(use-package org :ensure nil)

(with-eval-after-load 'org
  (add-hook 'org-mode-hook '+org-font-setup)
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-tab-first-hook 'org-end-of-line)
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars t)
  (setq org-startup-folded t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-ellipsis " ▾")
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-image-actual-width nil)
  (setq org-display-remote-inline-images 'download)
  (define-key org-mode-map (kbd "C-c C-h") 'consult-org-heading)
  (define-key org-mode-map (kbd "C-c l") 'org-insert-last-stored-link))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:D1E76232-405A-40C8-87B1-B553DBB57F43
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+org.el"
:END:

#+begin_src emacs-lisp
(require 'org-faces)

;;;###autoload
(defadvice! org-toggle-comment-ad (fn &rest args)
  "Drop-in replacement for `org-toggle-comment'.
This allows `org-toggle-comment' to toggle comment for all the
entries with the same level in the active region while behaves
the same when the region is inactive.  This is useful for
debugging code blocks in a org config file."
  :around #'org-toggle-comment
  (if (region-active-p)
      (progn
        (exchange-point-and-mark)
        (let ((end (region-end)) last-point)
          (while (< (point) end)
            (setq last-point (point))
            (apply fn args)
            (org-forward-heading-same-level 1)
            (when (eq last-point (point))
              (org-forward-element)))))
    (apply fn args)))

;;;###autoload
(defadvice! org-fill-paragraph-ad (&rest _)
  "Let `org-fill-paragraph' works inside of src block in Org-mode."
  :before-while #'org-fill-paragraph
  (let* ((element (save-excursion (beginning-of-line) (org-element-at-point)))
         (type (org-element-type element)))
    (if (and (eq type 'src-block)
             (> (line-beginning-position)
                (org-element-property :post-affiliated element))
             (< (line-beginning-position)
                (org-with-point-at (org-element-property :end element)
                  (skip-chars-backward " \t\n")
                  (line-beginning-position))))
        (progn (org-babel-do-in-edit-buffer (fill-paragraph)) nil)
      t)))

;;;###autoload
(defun +org-font-setup ()
  "Setup variable-pitch fonts for org-mode."
  (variable-pitch-mode)
  (let* ((families (font-family-list))
         (fallback `(:font ,(car families)))
         (variable-pitch (if (member grandview-variable-font families)
                             `(:font ,grandview-variable-font) fallback))
         (default (if (member grandview-default-font families)
                      `(:font ,grandview-default-font) fallback)))
    (custom-theme-set-faces
     'user
     `(org-level-1 ((t (,@variable-pitch :height 1.5))))
     `(org-level-2 ((t (,@variable-pitch :height 1.4))))
     `(org-level-3 ((t (,@variable-pitch :height 1.3))))
     `(org-level-4 ((t (,@variable-pitch :height 1.2))))
     `(org-table ((t (,@default))))
     `(org-verbatim ((t (,@default))))
     `(org-formula ((t (,@default))))
     `(org-code ((t (,@default))))
     `(org-block ((t (,@default))))
     `(org-block-begin-line ((t (:foreground "#606060" :extend t))))
     '(org-tag ((t (:inherit (shadow) :weight bold :height 0.8)))))))
#+end_src

** Identifiers for org entries (org-id.el)
:PROPERTIES:
:CUSTOM_ID: h:F86F6861-E18B-4790-9B87-28F1A8B10465
:END:

#+begin_src emacs-lisp
(use-package org-id :ensure nil)

(setq org-link-context-for-files t)
(setq org-link-keep-stored-after-insertion nil)
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:7269F6A0-67A5-4672-A32C-70711E30F3C5
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+org-id.el"
:END:

#+begin_src emacs-lisp
(require 'org-id)

;; Original idea:
;; <https://writequit.org/articles/emacs-org-mode-generate-ids.html>.
(defun +org-id--get ()
  "Get the CUSTOM_ID of the current entry.
If the entry already has a CUSTOM_ID, return it as-is, else create a new
one."
  (let* ((pos (point))
         (id (org-entry-get pos "CUSTOM_ID")))
    (if (and id (stringp id) (string-match-p "\\S-" id))
        id
      (setq id (org-id-new "h"))
      (org-entry-put pos "CUSTOM_ID" id)
      id)))

;;;###autoload
(defun +org-id-headlines ()
  "Add missing CUSTOM_ID to all headlines in current file."
  (interactive)
  (org-map-entries
   (lambda () (+org-id--get))))

;;;###autoload
(defun +org-id-headline ()
  "Add missing CUSTOM_ID to headline at point."
  (interactive)
  (+org-id--get))
#+end_src

** Literate programming (ob.el)
:PROPERTIES:
:CUSTOM_ID: h:A02ABD13-186B-410D-B78D-D64CA5C7ED9F
:END:

Thanks to https://blog.d46.us/advanced-emacs-startup

#+begin_src emacs-lisp
(use-package ob :ensure nil)
(use-package ob-C :ensure nil)
(use-package ob-js :ensure nil)
(use-package ob-shell :ensure nil)
(use-package ob-latex :ensure nil)
(use-package ob-makefile :ensure nil)
(use-package ob-csharp :vc (:url "https://github.com/samwdp/ob-csharp"))

(with-eval-after-load 'org
  (autoload 'org-babel-execute:C "ob-C")
  (autoload 'org-babel-expand:C "ob-C")
  (autoload 'org-babel-execute:cpp "ob-C")
  (autoload 'org-babel-expand:cpp "ob-C")
  (autoload 'org-babel-execute:csharp "ob-csharp")
  (autoload 'org-babel-execute:python "ob-python")
  (autoload 'org-babel-execute:js "ob-js")
  (autoload 'org-babel-execute:bash "ob-shell")
  (autoload 'org-babel-expand:latex "ob-latex")
  (autoload 'org-babel-execute:latex "ob-latex")
  (autoload 'org-babel-execute:makefile "ob-makefile")
  (setq org-babel-default-header-args:sh    '((:results . "output replace"))
        org-babel-default-header-args:bash  '((:results . "output replace"))
        org-babel-default-header-args:shell '((:results . "output replace"))))
#+end_src

** Source code block (org-src.el)
:PROPERTIES:
:CUSTOM_ID: h:34643643-4664-4119-AE64-FE72967C4F2C
:END:

#+begin_src emacs-lisp
(use-package org-src :ensure nil)

(with-eval-after-load 'org-src
  (setq org-src-window-setup 'split-window-right)
  (push '("conf-unix" . conf-unix) org-src-lang-modes))
#+end_src

** Reveal invisible org elements (org-appear.el)
:PROPERTIES:
:CUSTOM_ID: h:C3F87A9F-23E5-4B3E-A4BF-E2637C7C8050
:END:

#+begin_src emacs-lisp
(use-package org-appear :ensure t)

(add-hook 'org-mode-hook 'org-appear-mode)
(setq org-appear-autolinks t)
(setq org-hide-emphasis-markers t)
#+end_src

** Modern org style (org-modern.el)
:PROPERTIES:
:CUSTOM_ID: h:A8059D5E-D3A9-4345-88E4-883F3F099547
:END:

#+begin_src emacs-lisp
(use-package org-modern :ensure t)

(add-hook 'org-mode-hook 'org-modern-mode)
(add-hook 'org-agenda-finalize-hook 'org-modern-agenda)
#+end_src
** Habit (org-habit.el)
:PROPERTIES:
:CUSTOM_ID: h:413F6EA4-0A0F-4101-8EC3-2BBBDFC33C38
:END:

#+begin_src emacs-lisp
(use-package org-habit :ensure nil)

(with-eval-after-load 'org
  (appendq! org-modules '(org-habit))
  (setq org-habit-graph-column 60))
#+end_src

** Slide (org-tree-slide.el)
:PROPERTIES:
:CUSTOM_ID: h:D1DB04F4-C2FF-42C3-ACCC-25D4189C6B30
:END:

=org-tree-slide.el= is a presentation tool using =org-mode=.

#+begin_src emacs-lisp
(use-package org-tree-slide :ensure t)

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c |") 'org-tree-slide-mode))

(with-eval-after-load 'org-tree-slide
  (setq org-tree-slide-activate-message " ")
  (setq org-tree-slide-deactivate-message " ")
  (setq org-tree-slide-modeline-display nil)
  (setq org-tree-slide-heading-emphasis t)
  (setq org-tree-slide-breadcrumbs
        (propertize " ⯈ " 'display
                    `(height ,(face-attribute 'org-level-1 :height))))
  (add-hook 'org-tree-slide-after-narrow-hook #'org-display-inline-images)
  (add-hook 'org-tree-slide-after-narrow-hook #'+frame-cursor-dim-mode)
  ;; (add-hook 'org-tree-slide-mode-hook #'+org-tree-slide-hide-elements-h)
  ;; (add-hook 'org-tree-slide-play-hook #'+org-tree-slide-hide-elements-h)
  (add-hook 'org-tree-slide-mode-hook #'+org-tree-slide-prettify-slide-h)
  (define-key org-tree-slide-mode-map (kbd "<left>") 'org-tree-slide-move-previous-tree)
  (define-key org-tree-slide-mode-map (kbd "<right>") 'org-tree-slide-move-next-tree))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:13354F6E-FF7A-43DE-8DC4-43AF25D0DEA9
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+org-tree-slide.el"
:CUSTOM_ID: Org_mode-Slide_(org-tree-slide.el)-Autoload-7ff9d878
:END:

#+begin_src emacs-lisp
(defcustom +org-tree-slide-text-scale 1.5
  "Text scaling for `org-tree-slide-mode'."
  :group 'org-tree-slide
  :type 'number)

(defcustom +org-tree-hide-elements
  '(;; src block
    "^[[:space:]]*\\(#\\+\\)\\(\\(?:BEGIN\\|END\\|ATTR\\)[^[:space:]]+\\).*"
    ;; leading stars
    "^\\(\\*+\\)"
    ;; :PROPERTIES:.*:END:
    "\\(^:PROPERTIES:\\(.*\n\\)+?:END:\\)")
  "Regexps of org elements to hide in `org-tree-slide-mode'."
  :group 'org-tree-slide
  :type '(repeat string))

;;;###autoload
(defadvice! +org-tree-slide-simple-header-a (blank-lines)
  "Set the header with overlay.
Some number of BLANK-LINES will be shown below the header."
  :override #'org-tree-slide--set-slide-header
  (org-tree-slide--hide-slide-header)
  (setq org-tree-slide--header-overlay
        (make-overlay (point-min) (+ 1 (point-min))))
  (overlay-put org-tree-slide--header-overlay
               'face
               'org-tree-slide-header-overlay-face)
  (if org-tree-slide-header
      (overlay-put org-tree-slide--header-overlay 'display
                   (concat
                    (when org-tree-slide-breadcrumbs
                      (concat "\n" (org-tree-slide--get-parents
                                    org-tree-slide-breadcrumbs)))
                    (org-tree-slide--get-blank-lines blank-lines)))
    (overlay-put org-tree-slide--header-overlay 'display
                 (org-tree-slide--get-blank-lines blank-lines))))

;; ;;;###autoload
;; (defun +org-tree-slide-hide-elements-h ()
;;   "Hide org constructs defined in `+org-tree-hide-elements'."
;;   (dolist (reg +org-tree-hide-elements)
;;     (save-excursion
;;       (goto-char (point-min))
;;       (while (re-search-forward reg nil t)
;;         (org-fold-region (match-beginning 1) (match-end 0))))))

;;;###autoload
(defun +org-tree-slide-prettify-slide-h ()
  "Set up the org window for presentation."
  (cond (org-tree-slide-mode
         (text-scale-set +org-tree-slide-text-scale)
         (+frame-cursor-dim-mode +1)
         (+monocle-mode +1)
         (when (fboundp 'writeroom-mode) (writeroom-mode +1))
         (ignore-errors (org-latex-preview '(4))))
        (t
         (text-scale-set 0)
         (+monocle-mode -1)
         (+frame-cursor-dim-mode -1)
         (when (fboundp 'writeroom-mode) (writeroom-mode -1))
         (org-clear-latex-preview)
         (org-mode))))
#+end_src

* Programming
:PROPERTIES:
:CUSTOM_ID: h:2E097771-0569-462C-AB7A-4FA52F97E771
:END:

After proper configuration, Emacs can become a powerful and modern developing
environment.

** Github Copilot client (copilot.el)
:PROPERTIES:
:CUSTOM_ID: h:29D887A7-7848-4AD7-AB6C-B1E6CE0073B0
:END:

#+begin_src emacs-lisp
(use-package copilot
  :vc (:url "https://github.com/copilot-emacs/copilot.el"))

(with-eval-after-load 'copilot
  (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
  (define-key copilot-completion-map (kbd "TAB") 'copilot-accept-completion)
  (define-key copilot-completion-map (kbd "S-TAB") 'copilot-accept-completion-by-line))
#+end_src

** Client for LSP servers (eglot.el)
:PROPERTIES:
:CUSTOM_ID: h:D1EA3177-9AE1-44EE-8C71-E45FE5BF3AB5
:END:

*eglot* is the built-in language server protocol client in Emacs29+.

It's much simper and faster than *lsp-mode*, also it works well with all the
in-built emacs packages such as flymake, eldoc, etc.

We use =emacs-lsp-booster= (see: https://github.com/blahgeek/emacs-lsp-booster) to
speed up the json parsing, make sure you have the binary installed in your *PATH*.

Huge thanks to @blahgeek and @jdtsmith!

#+begin_src emacs-lisp
(use-package eglot :ensure nil)
(use-package markdown-mode :ensure t)
(use-package eglot-tempel :vc (:url "https://github.com/fejfighter/eglot-tempel"))
(use-package eglot-booster :vc (:url "https://github.com/jdtsmith/eglot-booster"))

(with-eval-after-load 'eglot
  (setq eglot-autoshutdown t)
  (setq eglot-send-changes-idle-time 0)
  (add-hook 'eglot-mode-hook '+eglot-setup-eldoc)
  (require 'eglot-tempel)
  (eglot-tempel-mode)
  (setq eglot-booster-io-only t)
  (add-hook 'eglot-mode-hook 'eglot-booster-mode))

(define-key grandview-prog-map (kbd "a") 'eglot-code-actions)
(define-key grandview-prog-map (kbd "t") 'eglot-find-typeDefinition)
(define-key grandview-prog-map (kbd "d") 'eglot-find-declaration)
(define-key grandview-prog-map (kbd "i") 'eglot-find-implementation)
(define-key grandview-prog-map (kbd "r") 'eglot-rename)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:BE13EC8F-A1C9-47C2-8EBC-CB34CA7E9546
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+eglot.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +eglot-setup-eldoc ()
  "Show docs for errors first, then signatures and others."
  (setq-local eldoc-documentation-functions
              '(flymake-eldoc-function
                eglot-signature-eldoc-function
                eglot-hover-eldoc-function)))
#+end_src

** Programming languages
:PROPERTIES:
:CUSTOM_ID: h:D0B53A0B-18C5-4246-A9EA-227DF576E301
:END:

Specfic configuartions for different programming languages.

*** Rust
:PROPERTIES:
:CUSTOM_ID: h:55CECA8C-5AF1-4A69-94C8-EE19FB31AEB3
:END:

#+begin_src emacs-lisp
(use-package rust-ts-mode :ensure nil)
#+end_src

*** Csharp
:PROPERTIES:
:CUSTOM_ID: h:FE82B63A-051F-4017-AF2D-39CAE2055730
:END:

Sharper is a Transient-based menu for the dotnet CLI. It aims to cover the most
common scenarios.  To invoke it, type =M-x sharper-main-transient= in a .cs file.

#+begin_src emacs-lisp
(use-package csharp-mode :ensure nil)
(use-package sharper :ensure t)

(add-to-list 'auto-mode-alist '("\\.cs\\'" . csharp-ts-mode))
(add-to-list 'auto-mode-alist '("\\.[a]?xaml\\'" . nxml-mode))

(with-eval-after-load 'csharp-mode
  (setq csharp-ts-mode-indent-offset 2)
  (require 'sharper)
  ;; A temporary fix for dotnet-sdk installation path on Apple Silicon machines
  (when (and (eq system-type 'darwin)
             (string-match "aarch64-.*" system-configuration))
    (setenv "DYLD_FALLBACK_LIBRARY_PATH" "/usr/local/lib:/usr/local/lib64:/opt/homebrew/lib")
    (setenv "DOTNET_ROOT" "/usr/local/share/dotnet")))
#+end_src

*** Python
:PROPERTIES:
:CUSTOM_ID: h:EA0C4A6F-7802-4918-BE58-74B92F26071F
:END:

#+begin_src emacs-lisp
(use-package python :ensure nil)

(add-to-list 'auto-mode-alist '("\\.py\\'" . python-ts-mode))

(setq python-indent-offset 2)
(setq python-indent-guess-indent-offset-verbose nil)
#+end_src

*** Lisp | Elisp
:PROPERTIES:
:CUSTOM_ID: h:578FBB21-6FDF-4845-8F05-A300039FF08E
:END:

#+begin_src emacs-lisp
(setq lisp-indent-offset nil)
#+end_src

*** Lua
:PROPERTIES:
:CUSTOM_ID: h:9531A99F-8F6E-4B98-9EE2-F152AACD6134
:END:

#+begin_src emacs-lisp
(use-package lua-ts-mode :ensure nil)

(add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-ts-mode))

(setq lua-indent-level 2)
#+end_src

*** Yaml
:PROPERTIES:
:CUSTOM_ID: h:013A24A9-6CC4-48B5-8681-EF53A79CDEC0
:END:

#+begin_src emacs-lisp
(use-package yaml-ts-mode :ensure nil)

(add-to-list 'auto-mode-alist '("\\.y[a]?ml\\'" . yaml-ts-mode))
#+end_src

*** Javascript | Typescript
:PROPERTIES:
:CUSTOM_ID: h:9EB7B53E-7346-4236-A5BF-67594F996D3F
:END:

#+begin_src emacs-lisp
(use-package js :ensure nil)
(use-package typescript-ts-mode :ensure nil)

(add-to-list 'auto-mode-alist '("\\.js\\'" . js-ts-mode))
(add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))

(add-hook 'typescript-ts-mode-hook #'eglot-ensure)
(setq js-indent-level 2)
#+end_src

*** Vue
:PROPERTIES:
:CUSTOM_ID: h:D9E48633-7EE3-42CB-B0CA-C9CC6F71E7D6
:END:

#+begin_src emacs-lisp
(use-package vue-ts-mode :vc (:url "https://github.com/8uff3r/vue-ts-mode"))

(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs +vue-ts-eglot-lsp-option))

(with-eval-after-load 'copilot
  (add-to-list
   'copilot-indentation-alist '(vue-ts-mode vue-ts-mode-indent-offset)))

(add-to-list 'auto-mode-alist '("\\.vue\\'" . vue-ts-mode))
(add-hook 'vue-ts-mode-hook #'eglot-ensure)
(setq vue-ts-mode-indent-offset 2)
#+end_src

**** Autoload
:PROPERTIES:
:CUSTOM_ID: h:3711C8CE-5305-4F82-9905-0A8DB2F843A8
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+Vue.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defcustom +vue-ts-eglot-lsp-option
  '((vue-ts-mode typescript-ts-mode) .
    ("vue-language-server" "--stdio"
     :initializationOptions
     (:typescript
      (:tsdk
       "/opt/homebrew/lib/node_modules/typescript/lib"
       :languageFeatures
       (:completion
        (:defaultTagNameCase
         "both" :defaultAttrNameCase "kebabCase"
         :getDocumentNameCasesRequest nil
         :getDocumentSelectionRequest nil)
        :diagnostics (:getDocumentVersionRequest nil))
       :documentFeatures
       (:documentFormatting
        (:defaultPrintWidth
         100 :getDocumentPrintWidthRequest nil)
        :documentSymbol t :documentColor t))
      :vue (:hybridMode :json-false))))
  "Lsp client options for vue - typescript project.
The string followed by `:tsdk' is the path to typescript sdk library,
which may vary across in different OS, usually you can get the path by
evaluate the code below:
`(expand-file-name \"lib\" (string-trim-right
  (shell-command-to-string \"npm list -g -p typescript | head -n1\")))'
It basically instructs npm to find the path by itself.  Run this npm
query is quite expensive and slow, which makes emacs lag for a second
everytime a new vue typescript project is opened.  Hence, set it
manually seems a better option."
  :type 'eglot-server-program)
#+end_src

*** Css
:PROPERTIES:
:CUSTOM_ID: h:FB19DD40-5FE1-4020-A5A4-35F622F1015F
:END:

#+begin_src emacs-lisp
(use-package css-mode :ensure nil)

(add-to-list 'auto-mode-alist '("\\.css\\'" . css-ts-mode))

(setq css-indent-offset 2)
#+end_src

*** Bash | Zsh
:PROPERTIES:
:CUSTOM_ID: h:688926D3-73C7-4916-A001-759600DCC64C
:END:

#+begin_src emacs-lisp
(use-package sh-script :ensure nil)

(setq sh-basic-offset 2)
#+end_src

** Show help / diagnostic info at point (eldoc.el)
:PROPERTIES:
:CUSTOM_ID: h:88EA4FBD-F7DC-436C-8515-8095306CE126
:END:

For languages like emacs-lisp, this package shows function arglist or variable
docstring in echo area.  For other programming languages, thanks to the
=eldoc-documentation-functions'= hook it provides, any help or diagnostic info
that are relevent to the symbol (whatever it is) under the cursor will be
displayed in the minibuffer.

If the information string is more than one line, by default eldoc will
automatically expand and shrink the minibuffer, which I don't like very much.
So I turn =eldoc-echo-area-use-multiline-p= off.

#+begin_src emacs-lisp
(setq eldoc-echo-area-use-multiline-p nil)
#+end_src

** Compiler (compile.el)
:PROPERTIES:
:CUSTOM_ID: h:D6A16E5A-D417-4585-843F-92F206900B84
:END:

Run compiler as inferior of Emacs, parse error messages.

#+begin_src emacs-lisp
(define-key grandview-file-map (kbd "p") 'compile)
(define-key grandview-file-map (kbd "P") 'recompile)
#+end_src

** Jupyter (jupyter.el)
:PROPERTIES:
:CUSTOM_ID: h:76B9895A-72F7-4BB4-B46C-2F087FCA81E8
:END:

#+begin_src emacs-lisp
(use-package jupyter :ensure t)

(with-eval-after-load 'jupyter
  (require 'ob-jupyter)
  (org-babel-jupyter-override-src-block "python")
  (setq org-babel-default-header-args:python
        '((:async . "yes") (:kernel . "python3"))))
#+end_src

** Colorizer (rainbow-mode.el)
:PROPERTIES:
:CUSTOM_ID: h:A5576BEA-6543-4DF6-AAAF-A2F689D64BA7
:END:

#+begin_src emacs-lisp
(use-package rainbow-mode :ensure t)

(add-hook 'prog-mode-hook 'rainbow-mode)
#+end_src

** Formatter (reformatter.el)
:PROPERTIES:
:CUSTOM_ID: h:6E21C502-9ADA-452C-B4B9-C10D88CD42CB
:END:

=reformatter.el= (created by Purcell) lets you easily define an idiomatic command
to reformat the current buffer using a command-line program, together with an
optional minor mode which can apply this command automatically on save.

#+begin_src emacs-lisp
(use-package reformatter :ensure t)

(define-key grandview-prog-map (kbd "f") '+format-buffer)

(with-eval-after-load 'reformatter
  (reformatter-define lua-format
    :program "stylua"
    :args '("--indent-width" "2" "-")
    :lighter " styLua")
  (reformatter-define python-format
    :program "black"
    :args '("-")
    :lighter " blackFMT")
  (reformatter-define vue-format
    :program "eslint_d"
    :args (list "--stdin" "--fix-to-stdout" "--stdin-filename" (buffer-file-name))
    :working-directory (+reformatter-eslint-root)
    :lighter " eslint")
  (reformatter-define typescript-format
    :program "eslint_d"
    :args (list "--stdin" "--fix-to-stdout" "--stdin-filename" (buffer-file-name))
    :working-directory (+reformatter-eslint-root)
    :lighter " eslint")
  (add-hook 'vue-ts-mode-hook #'vue-format-on-save-mode)
  (add-hook 'vue-ts-mode-hook #'typescript-format-on-save-mode))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:91FB5726-4A78-403A-8DF6-3D0B2644C6B4
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+reformatter.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +reformatter-eslint-root ()
  "Up traverse filesystem for a directory containing eslint config."
  (locate-dominating-file
   default-directory
   (lambda (directory)
     (seq-find
      (lambda (project-marker)
        (file-exists-p (expand-file-name project-marker directory)))
      '("eslint.config.js" "eslint.config.mjs" "eslint.config.cjs" "package.json")))))

;;;###autoload
(defun +format-buffer ()
  (interactive)
  (let* ((mode-name
          (string-remove-suffix
           "-mode" (string-remove-suffix "-ts-mode" (format "%s" major-mode))))
         (func-name (intern (format "%s-format-buffer" mode-name))))
    (if (functionp func-name)
        (funcall func-name)
      (user-error
       (format
        "No available formatter for %s. Use `reformatter-define' to create it."
        major-mode)))))
#+end_src

** Syntax checker (flymake.el)
:PROPERTIES:
:CUSTOM_ID: h:06C35376-E12F-4587-BD8E-B0EC021E2F08
:END:

#+begin_src emacs-lisp
(use-package flymake :ensure nil)

(add-hook 'prog-mode-hook '+flymake-enable)
(add-hook 'text-mode-hook 'flymake-mode)
(define-key grandview-prog-map (kbd "e") 'flymake-goto-next-error)
(define-key grandview-prog-map (kbd "E") 'flymake-goto-prev-error)
(define-key grandview-prog-map (kbd "S") 'flymake-start)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:AE26DC0C-1792-4840-A2B4-DFDC227BA78C
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+flymake.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +flymake-enable ()
  "Inhibit `flymake-mode' under certain circumstances."
  (unless (or (equal default-directory
                     (or (file-name-directory grandview--dot-org)
                         user-emacs-directory))
              (eq (current-buffer) (get-buffer "*scratch*")))
    (flymake-mode +1)))
#+end_src

** REST client (restclient.el)
:PROPERTIES:
:CUSTOM_ID: h:A25206AC-05E6-4F4D-A161-C295484936FF
:END:

#+begin_src emacs-lisp
(use-package restclient :ensure t)
#+end_src

** Scratch buffer (scratch.el)
:PROPERTIES:
:CUSTOM_ID: h:13503906-8D66-4DF7-93A3-EA726D9C1771
:END:

=+scratch= command produces a org-mode buffer with right header-args for current
jupyter kernel.  Use it with =SPC f s=, doing it with a prefix argument (=C-u=) will
prompt for a major mode instead.  Simple yet super effective!

#+begin_src emacs-lisp
(define-key grandview-util-map (kbd "s") '+scratch)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:DB49C042-A133-4B4B-9773-36016E5009B1
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+scratch.el"
:END:

#+begin_src emacs-lisp
(defun +scratch--list-modes ()
  "List known major modes."
  (cl-loop for sym the symbols of obarray
           for name = (symbol-name sym)
           when (and (functionp sym)
                     (not (member sym minor-mode-list))
                     (string-match "-mode$" name)
                     (not (string-match "--" name)))
           collect (substring name 0 -5)))

;;;###autoload
(defun +scratch (query-for-mode)
  "Create or switch to an org-mode scratch buffer.
A jupyter session is attached to the buffer.
If called with prefix arg, prompt for a major mode for the buffer."
  (interactive "P")
  (let ((buf (get-buffer "*Grandview-scratch*")))
    (unless buf
      (let* ((new-buf (generate-new-buffer "*Grandview-scratch*"))
             (jpt-session "base")
             (text (concat "#+PROPERTY: header-args:python :session "
                           jpt-session))
             (mode "org"))
        (with-current-buffer new-buf
          (when query-for-mode
            (setq mode (completing-read
                        "Mode: " (+scratch--list-modes) nil t nil nil))
            (setq text (format "Scratch buffer for: %s" mode)))
          (insert text)
          (funcall (intern (concat mode "-mode")))
          (setq-local org-image-actual-width '(1024))
          (unless (string= mode "org") (comment-region (point-min) (point-max)))
          (insert "\n\n")
          (setq buf new-buf))))
    (pop-to-buffer buf)))
#+end_src

* User interface
:PROPERTIES:
:CUSTOM_ID: h:6762E5C6-D007-452E-8328-47EF50515A8B
:END:

** Highlight focused window (auto-dim-other-buffers.el)
:PROPERTIES:
:CUSTOM_ID: h:1F76247C-9DAE-4BA7-B6B0-CEF3A8870EFA
:END:

Just dim other windows out so that we know better which window is the focused
one.  We only load this package after we have more than 1 windows.

#+begin_src emacs-lisp
(use-package auto-dim-other-buffers :ensure t :after-call split-window)

(with-eval-after-load 'auto-dim-other-buffers
  (auto-dim-other-buffers-mode))
#+end_src

** Workspaces (tabspaces.el)
:PROPERTIES:
:CUSTOM_ID: h:AF5996B4-03F2-439A-8EA9-4087A2C152C9
:END:

Use the inbuilt =tab-bar.el= and the package =tabspaces.el= to create workspaces.

- General tab bar customization
- Enable ~tabspaces-mode~
- Create some default workspaces
- Filter buffers for consult tabspaces
- Rename the first tab (generated by tab-bar itself) to =Default=

#+begin_src emacs-lisp
(use-package tabspaces :ensure t)

(require 'tabspaces)
(tabspaces-mode 1)
(add-hook 'server-after-make-frame-hook #'+tabspaces-setup)

(setq tab-bar-separator " "
      tab-bar-close-button-show nil
      tab-bar-close-last-tab-choice 'tab-bar-mode-disable
      tab-bar-tab-name-format-function #'+tabspaces-tab-name-format-comfortable
      tab-bar-format '(+tabspaces-format-menu-bar
                       tab-bar-format-tabs
                       tab-bar-separator
                       tab-bar-format-align-right
                       tab-bar-format-global)
      tabspaces-keymap-prefix nil
      tabspaces-default-tab "Default"
      tabspaces-include-buffers '("*scratch*" "*Messages*")
      tabspaces-remove-to-default t)

(with-eval-after-load 'tabspaces
  (define-key 'grandview-workspace-map (kbd "C") 'tabspaces-clear-buffers)
  (define-key 'grandview-workspace-map (kbd "R") 'tabspaces-remove-selected-buffer)
  (define-key 'grandview-workspace-map (kbd "k") 'tabspaces-kill-buffers-close-workspace)
  (define-key 'grandview-workspace-map (kbd "s") 'tabspaces-switch-or-create-workspace))

(with-eval-after-load 'consult
  (consult-customize consult--source-buffer :hidden t :default nil)
  (defvar consult--source-workspace
    (list :name "Workspace Buffers"
          :narrow ?w
          :history 'buffer-name-history
          :category 'buffer
          :state #'consult--buffer-state
          :default t
          :items (lambda () (consult--buffer-query
                             :predicate #'tabspaces--local-buffer-p
                             :sort 'visibility
                             :as #'buffer-name)))
    "Set Workspace buffer list for consult buffer.")
  (add-to-list 'consult-buffer-sources 'consult--source-workspace))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:FF6995C8-B5C2-4B1A-A1D6-1E1780E1F582
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+tabspaces.el"
:END:

#+begin_src emacs-lisp
(defcustom +tabspaces-startup-workspaces nil
  "Workspaces being created at startup."
  :group 'grandview :type 'alist)

;;;###autoload
(defun +tabspaces-format-menu-bar ()
  "Produce the Menu button for the tab bar that shows the menu bar."
  `((menu-bar menu-item (propertize " 𝝺" 'face 'tab-bar)
              tab-bar-menu-bar :help "Menu Bar")))

;;;###autoload
(defun +tabspaces-tab-name-format-comfortable (tab i)
  (propertize (concat " " (tab-bar-tab-name-format-default tab i) " ")
              'face (funcall tab-bar-tab-face-function tab)))

(defun +tabspaces-create-workspace (name &optional path)
  "Setup the workspace with name NAME and startup path PATH."
  (if (member name (tabspaces--list-tabspaces))
      (progn (tab-bar-switch-to-tab name)
             (when (and (not (get-buffer name)) path) (dirvish path)))
    (tab-bar-new-tab)
    (tab-bar-rename-tab name)
    (when path (dirvish path))))

;;;###autoload
(defun +tabspaces-setup ()
  "Setup tabspaces when a frame is created as well."
  (cl-loop for (name . path) in +tabspaces-startup-workspaces
           do (+tabspaces-create-workspace name path))
  (tab-bar-select-tab 1)
  (tab-bar-rename-tab "Default"))
#+end_src

** Transient commands (transient.el)
:PROPERTIES:
:CUSTOM_ID: h:6C19254F-E941-4E51-A443-3F8A7D796589
:END:

=transient.el= implements support for powerful keyboard-driven menus.  Such menus
can be used as simple visual command dispatchers.  More complex menus take
advantage of infix arguments, which are somewhat similar to prefix arguments,
but are more flexible and discoverable.  This package is inbuilt with Emacs 28+.

#+begin_src emacs-lisp
(use-package transient :ensure nil)

(with-eval-after-load 'transient
  (setq transient-enable-popup-navigation nil)
  (setq transient-default-level 7)
  (setq transient-show-popup -0.2)
  (transient-bind-q-to-quit)
  (setq transient-display-buffer-action '(display-buffer-below-selected))
  (define-key transient-map (kbd "<escape>") 'transient-quit-all)
  (define-key transient-sticky-map (kbd "ESC") 'transient-quit-all))
#+end_src

** Custom Mode line
:PROPERTIES:
:CUSTOM_ID: h:9C974B19-F47B-4758-87BD-A889965D7239
:END:

The following infos in modeline are provided:

+ Left ::
  - Meow current state (INSERT/NORMAL...)
  - Buffer info (icon, name, modified state)
  - Macro recording state

+ Right ::
  - Current line / column
  - Input method

Besides, it's easy to define your own mode line segments with
~+mode-line-define-segment~, and don't forget to put your newly defined segments
in ~+mode-line-format~.

#+begin_src emacs-lisp
(+mode-line-mode)
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:E77C4AD0-D38E-43D5-AFAC-C3135D88A444
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+Custom_Mode_line.el"
:END:

#+begin_src emacs-lisp
(defun +mode-line--fmt-setter (k fmt)
  "Setter for `+mode-line-format'."
  (cl-labels ((expand (l)
                (cl-loop for s in l collect
                         `(:eval (+mode-line--suffix
                                  ',(intern (format "+mode-line-%s-seg" s)))))))
    (let ((fmt-left (or (expand (plist-get fmt :left)) mode-line-format))
          (fmt-right (expand (plist-get fmt :right))))
      (set k `((:eval
                (let* ((str-right (format-mode-line ',fmt-right))
                       (spec `((space :align-to
                                      (- (+ right right-fringe right-margin)
                                         ,(string-width str-right))))))
                  (concat (format-mode-line ',fmt-left)
                          (propertize " " 'display spec)
                          str-right))))))))

(defcustom +mode-line-format
  '(:left
    (bar editing-state buffer-info macro-rec)
    :right
    (position input-method))
  "Mode line SEGMENTs aligned to left/right respectively.
The SEGMENTs are defined by `+mode-line-define'."
  :set #'+mode-line--fmt-setter)

(defcustom +mode-line-height 21
  "Modeline's height in pixel.")

(defvar +mode-line-selected-window nil)

(defun +mode-line-disable-locally ()
  "Do not show mode line in this buffer."
  (setq mode-line-format nil))

(defun +mode-line--window-active ()
  "Return t if mode line is in active window."
  (unless (and (bound-and-true-p mini-frame-frame)
               (and (frame-live-p mini-frame-frame)
                    (frame-visible-p mini-frame-frame)))
    (and +mode-line-selected-window
         (eq (+mode-line--get-current-window) +mode-line-selected-window))))

(defun +mode-line--get-current-window (&optional frame)
  "Get the current window but should exclude the child windows."
  (if (and (fboundp 'frame-parent) (frame-parent frame))
      (frame-selected-window (frame-parent frame))
    (frame-selected-window frame)))

(defun +mode-line-record-selected-window-h (&rest _)
  "Update `+mode-line-selected-window' on redisplay."
  (let ((win (+mode-line--get-current-window)))
    (setq +mode-line-selected-window
          (if (minibuffer-window-active-p win)
              (minibuffer-selected-window)
            win))))

(add-hook 'window-selection-change-functions #'+mode-line-record-selected-window-h)

(defun +mode-line--suffix (ml-func)
  "If ML-FUNC return a non-empty string, append a space to it."
  (when-let* ((str (funcall ml-func))) (concat str " ")))

(cl-defmacro +mode-line-define (name &optional docstr &rest body)
  "Define a mode line segment NAME with BODY and DOCSTR."
  (declare (indent defun) (doc-string 2))
  (let ((ml (intern (format "+mode-line-%s-seg" name))))
    `(defun ,ml () ,docstr ,@body)))

(+mode-line-define bar
  (when (and (display-graphic-p) (image-type-available-p 'pbm))
    (propertize
     " " 'display
     (ignore-errors
       (create-image
        (concat (format "P1\n%i %i\n" 2 +mode-line-height)
                (make-string (* 2 +mode-line-height) ?1) "\n")
        'pbm t :foreground "None" :ascent 'center)))))

(+mode-line-define position
  (concat (propertize "l " 'face 'font-lock-keyword-face)
          (propertize "%l " 'face 'font-lock-doc-face)
          (propertize "c " 'face 'font-lock-keyword-face)
          (propertize "%c" 'face 'font-lock-doc-face)))

(+mode-line-define editing-state
  (when (bound-and-true-p meow-mode) (meow-indicator)))

(+mode-line-define buffer-info
  (concat
   (and buffer-file-name (nerd-icons-icon-for-file
                          buffer-file-name :height 0.75 :v-adjust 0.02))
   " "
   (propertize "%b"
               'face (cond ((and buffer-file-name (buffer-modified-p))
                            'marginalia-modified)
                           ((+mode-line--window-active) 'bold)
                           (t 'mode-line-inactive))
               'mouse-face 'mode-line-highlight
               'help-echo
               "Buffer name\nmouse-1: Previous buffer\nmouse-3: Next buffer"
               'local-map mode-line-buffer-identification-keymap)))

(+mode-line-define macro-rec
  (when (or defining-kbd-macro executing-kbd-macro)
    (propertize "KM" 'face 'warning)))

(+mode-line-define input-method
  (when (bound-and-true-p rime-mode) (rime-lighter)))

(defvar +mode-line--default-mode-line mode-line-format
  "Store the default mode-line format")

;;;###autoload
(define-minor-mode +mode-line-mode
  "Toggle `+mode-line-mode' on or off."
  :global t
  (if +mode-line-mode
      (progn
        (setq-default mode-line-format +mode-line-format)
        (add-hook 'compilation-mode-hook #'+mode-line-disable-locally))
    (setq-default mode-line-format +mode-line--default-mode-line)
    (remove-hook 'compilation-mode-hook #'+mode-line-disable-locally)))
#+end_src

** Frame margin (fringe.el)
:PROPERTIES:
:CUSTOM_ID: h:55DA6FDA-C0E0-44A3-8335-DD6D5D5C18E1
:END:

+ Redefine word wrap arrow at fringe
+ Create a 20 pixel margin for emacs frame

#+begin_src emacs-lisp
(define-fringe-bitmap 'right-curly-arrow  [])
(define-fringe-bitmap 'left-curly-arrow  [])
(add-to-list 'default-frame-alist '(internal-border-width . 10))
(add-to-list 'default-frame-alist '(left-fringe . 1))
(add-to-list 'default-frame-alist '(right-fringe . 1))
(fringe-mode '(1 . 1))
#+end_src

** Pixel scrolling (pixel-scroll.el)
:PROPERTIES:
:CUSTOM_ID: h:E59DA6AB-6266-4CFA-BA46-97A4A8382F11
:END:

Pixelwise scrolling in emacs. This  was added in emacs version > 29, you
need to add =--with-xinput2= in build flags to enable this feature.

#+begin_src emacs-lisp
(when (boundp 'pixel-scroll-precision-mode)
  (pixel-scroll-precision-mode 1))
#+end_src

** Pulse highlight on demand or after select functions (pulsar.el)
:PROPERTIES:
:CUSTOM_ID: h:F45A1F5E-7445-4427-B27F-CAF6EB415744
:END:

Another great package from Prot!

#+begin_src emacs-lisp
(use-package pulsar :ensure t)

(pulsar-global-mode)
(with-eval-after-load 'pulsar
  (appendq! pulsar-pulse-functions
            (list 'windmove-left 'windmove-right
                  'windmove-up 'windmove-down
                  'previous-window-any-frame
                  'next-window-any-frame
                  'meow-save 'meow-replace)))
#+end_src

** VSCode style icons (vscode-icon.el)
:PROPERTIES:
:CUSTOM_ID: h:AE04910B-3A25-4DCD-BC41-B4CF27F82A5B
:END:

Similar to =all-the-icons.el=, =vscode-icon= is a icon library which provides VSCode
style icons with image format.

#+begin_src emacs-lisp
(use-package vscode-icon :ensure t)

(with-eval-after-load 'vscode-icon
  (push '("jpg" . "image") vscode-icon-file-alist)
  (push '("7z" . "zip") vscode-icon-file-alist)
  (push '("mkv" . "video") vscode-icon-file-alist)
  (push '("epub" . "storybook") vscode-icon-file-alist))
#+end_src

** Interactive query replace (anzu.el)
:PROPERTIES:
:CUSTOM_ID: h:81C344C7-6981-4526-A34B-6EBAB2590CF0
:END:

=anzu.el= provides a minor mode which displays 'current match/total
matches' in the mode-line in various search modes.  This makes it
easy to understand how many matches there are in the current buffer
for your search query.

#+begin_src emacs-lisp
(use-package anzu :ensure t :after-call isearch-mode)

(with-eval-after-load 'anzu
  (global-anzu-mode)
  (define-key global-map [remap query-replace] 'anzu-query-replace)
  (define-key global-map [remap query-replace-regexp] 'anzu-query-replace-regexp))
#+end_src

** Alternative isearch UI (isearch-mb.el)
:PROPERTIES:
:CUSTOM_ID: h:EFA1CC25-8309-4639-A358-8F2B1BC1AE79
:END:

This package provides an alternative isearch UI based on the minibuffer.  This
allows editing the search string in arbitrary ways without any special maneuver;
unlike standard isearch, cursor motion commands do not end the search.
Moreover, the search status information in the echo area and some keybindings
are slightly simplified.

#+begin_src emacs-lisp
(use-package isearch-mb :ensure t :after-call isearch-mode)

(with-eval-after-load 'isearch-mb
  (isearch-mb-mode)
  (add-to-list 'isearch-mb--with-buffer #'consult-isearch-history)
  (add-to-list 'isearch-mb--after-exit #'anzu-isearch-query-replace)
  (define-key isearch-mb-minibuffer-map
              [remap previous-matching-history-element] 'consult-isearch-history))
#+end_src

** Distraction-free writing (writeroom-mode.el)
:PROPERTIES:
:CUSTOM_ID: h:30BCB780-6A36-45D4-8A5F-DC207C8587BB
:END:

#+begin_src emacs-lisp
(use-package writeroom-mode :ensure t :after-call org-mode-hook markdown-mode-hook)

(with-eval-after-load 'writeroom-mode
  (setq writeroom-width 128
        writeroom-bottom-divider-width 0
        writeroom-fringes-outside-margins t
        writeroom-fullscreen-effect 'fullboth
        writeroom-major-modes '(text-mode prog-mode conf-mode special-mode Info-mode)
        writeroom-major-modes-exceptions '(process-menu-mode proced-mode)
        writeroom-maximize-window nil
        writeroom-mode-line t)
  (add-hook 'org-mode-hook #'+visual-fill-center-text))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:FC7300FE-855C-4AC5-9272-689829C7D4D7
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+writeroom-mode.el"
:END:

#+begin_src emacs-lisp
;;;###autoload
(defun +visual-fill-center-text ()
  "Centering text."
  (interactive)
  (setq-local visual-fill-column-width 120)
  (setq-local visual-fill-column-center-text t)
  (visual-fill-column-mode 1))
#+end_src

** Hunk indicator (git-gutter.el)
:PROPERTIES:
:CUSTOM_ID: h:0969690B-0AF3-46AE-8A9E-F61150723E9F
:END:

#+begin_src emacs-lisp
(use-package git-gutter :ensure t)

(setq git-gutter:modified-sign "⏽"
      git-gutter:added-sign "⏽"
      git-gutter:deleted-sign "⏽")
#+end_src

* Utils
:PROPERTIES:
:CUSTOM_ID: h:D57D39A0-DFEB-48BF-BBCB-832522B6DF9B
:END:

** Keyboard version right-click (embark.el)
:PROPERTIES:
:CUSTOM_ID: h:80BF3F35-E8B5-4710-88AD-3942261EF07B
:END:

This package provides a sort of right-click contextual menu for Emacs, accessed
through the ~embark-act~ command (which you should bind to a convenient key),
offering you relevant actions to use on a target determined by the context.

#+begin_src emacs-lisp
(use-package embark :ensure t :after-call display-buffer minibuffer-setup-hook)
(use-package embark-consult :ensure t :after embark)

(with-eval-after-load 'embark
  (setq embark-quit-after-action t)
  (define-key global-map (kbd "C-.") 'embark-act)
  (define-key minibuffer-local-map (kbd "C-.") 'embark-act)
  (define-key minibuffer-local-map (kbd "C-,") 'embark-become))
#+end_src

** Vterm (vterm.el)
:PROPERTIES:
:CUSTOM_ID: h:B49FA4E0-EB36-4734-AF25-54D6E6EFEBA6
:END:

#+begin_src emacs-lisp
(use-package vterm :ensure t)

(define-key global-map (kbd "s-`") '+vterm-toggle)

(with-eval-after-load 'vterm
  (+vterm-mux-mode)
  (setq vterm-max-scrollback 5000)
  (add-hook 'vterm-copy-mode-hook
            (lambda () (if vterm-copy-mode (meow-normal-mode) (meow-insert-mode))))
  (define-key vterm-mode-map (kbd "s-`") '+vterm-toggle)
  (define-key vterm-mode-map (kbd "s--") '+vterm-new)
  (define-key vterm-mode-map (kbd "s-.") '+vterm-next)
  (define-key vterm-mode-map (kbd "s-,") '+vterm-prev)
  (define-key vterm-mode-map (kbd "s-n") 'vterm-next-prompt)
  (define-key vterm-mode-map (kbd "s-p") 'vterm-previous-prompt)
  (define-key vterm-mode-map (kbd "C-<backspace>") '+vterm-send-F4)
  (define-key vterm-mode-map (kbd "C-/") '+vterm-send-F6)
  (define-key vterm-mode-map (kbd "C-,") '+vterm-send-F10)
  (define-key vterm-mode-map (kbd "C-.") '+vterm-send-F11)
  (define-key vterm-mode-map (kbd "C-;") '+vterm-send-F12)
  (define-key vterm-mode-map (kbd "S-SPC") nil)
  (define-key vterm-mode-map (kbd "S-<escape>") 'vterm-copy-mode)
  (define-key vterm-copy-mode-map (kbd "S-<escape>") 'vterm-copy-mode-done))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:B05AAF84-FA1E-42FC-8C55-C7C9AD951D7E
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+vterm.el"
:END:

#+begin_src emacs-lisp
(require 'vterm)

(defcustom +vterm-position-alist
  '((always . ((window-height . 0.2) (side . bottom))))
  "doc")

(defvar +vterm-buffers nil
  "The list of non-dedicated vterm buffers.")

(defvar +vterm-index 0
  "The index of current vterm buffer.")

;;;###autoload
(defadvice! +vterm-escape-a (fn &rest args)
  :around #'meow-insert-exit
  (if (derived-mode-p 'vterm-mode)
      (vterm-send-escape)
    (apply fn args)))

;;;###autoload
(defadvice! +vterm-kill-whole-line-a (fn &rest args)
  :around #'meow-kill-whole-line
  (if (derived-mode-p 'vterm-mode)
      (vterm-send-key "<f5>" nil nil nil)
    (apply fn args)))

;;;###autoload
(defadvice! +vterm-backword-char-a (fn &rest args)
  :around #'meow-right
  (if (derived-mode-p 'vterm-mode)
      (vterm-send-key "<f3>" nil nil nil)
    (apply fn args)))

(defun +vterm--disable-side-window (fn &rest args)
  "Prevent vterm size adjust break selection."
  (unless (and (region-active-p)
               (derived-mode-p 'vterm-mode))
    (apply fn args)))

;;;###autoload
(defun +vterm-send-F4 ()
  (interactive)
  (vterm-send-key "<f4>" nil nil nil))

;;;###autoload
(defun +vterm-send-F6 ()
  (interactive)
  (vterm-send-key "<f6>" nil nil nil))

;;;###autoload
(defun +vterm-send-F10 ()
  (interactive)
  (vterm-send-key "<f10>" nil nil nil))

;;;###autoload
(defun +vterm-send-F11 ()
  (interactive)
  (vterm-send-key "<f11>" nil nil nil))

;;;###autoload
(defun +vterm-send-F12 ()
  (interactive)
  (vterm-send-key "<f12>" nil nil nil))

(defun +vterm--get-win-params ()
  "Parse `+vterm-position-alist' to get vterm display parameters."
  `(("^\\*vterm.*"
     (display-buffer-in-side-window)
     (window-parameters . ((mode-line-format . none)))
     ,@(cl-loop for (pred . pos) in +vterm-position-alist
                thereis (and (funcall pred) pos)))))

;;;###autoload
(defun +vterm-toggle (&optional project-root)
  "Toggle vterm.
If called with prefix argument, create a new vterm buffer with
project root directory as `default-directory'."
  (interactive "P")
  (if (eq major-mode 'vterm-mode)
      (delete-window)
    (let* ((display-buffer-alist (+vterm--get-win-params))
           (buf (nth +vterm-index +vterm-buffers))
           (pr-root (or (ignore-errors
                          (project-root (project-current)))
                        default-directory))
           (default-directory (if project-root pr-root default-directory))
           (index (if buf (+vterm--get-index buf) 0)))
      (add-to-list '+vterm-buffers (vterm index))
      (meow-insert))))

(defun +vterm--get-index (buf)
  (let* ((name (buffer-name buf)))
    (string-match "\\*vterm\\*\<\\([0-9]+\\)\>" name)
    (string-to-number (cl-subseq name (match-beginning 1) (match-end 1)))))

(declare-function meow-insert "meow-command")

;;;###autoload
(defun +vterm-new ()
  "Create new vterm buffer."
  (interactive)
  (let ((new-index (1+ (+vterm--get-index (car +vterm-buffers))))
        (display-buffer-alist (+vterm--get-win-params)))
    (add-to-list '+vterm-buffers (vterm new-index))
    (meow-insert)))

;;;###autoload
(defun +vterm-next (&optional arg)
  "Select next vterm buffer.
Create new one if no vterm buffer exists."
  (interactive "P")
  (let* ((curr-index (cl-position (current-buffer) +vterm-buffers))
         (new-index (+ curr-index (or arg -1)))
         (buf (nth new-index +vterm-buffers)))
    (when buf
      (switch-to-buffer buf)
      (setq +vterm-index new-index))))

;;;###autoload
(defun +vterm-prev (&optional arg)
  "Select previous vterm buffer."
  (interactive "p")
  (+vterm-next arg))

(defun +vterm--kill-buffer ()
  "Remove killed buffer from `+vterm-buffers'.

Used as a hook function added to `kill-buffer-hook'."
  (let* ((buf (current-buffer))
         (name (buffer-name buf)))
    (when (string-prefix-p "*vterm" name)
      (delq! buf +vterm-buffers))))

;;;###autoload
(define-minor-mode +vterm-mux-mode
  "Show/hide multiple vterm windows under control."
  :global t
  :group 'vterm
  (if +vterm-mux-mode
      (progn
        (advice-add
         'display-buffer-in-side-window :around '+vterm--disable-side-window)
        (add-hook 'kill-buffer-hook #'+vterm--kill-buffer))
    (advice-remove 'display-buffer-in-side-window '+vterm--disable-side-window)
    (remove-hook 'kill-buffer-hook #'+vterm--kill-buffer)))
#+end_src

** Git porcelain (magit.el)
:PROPERTIES:
:CUSTOM_ID: h:2F3C245E-4DE8-46F4-9168-0B45BED441E1
:END:

#+begin_src emacs-lisp
(use-package magit :ensure t)

(define-key global-map (kbd "C-M-g") 'magit-status-here)
(with-eval-after-load 'magit
  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-define-global-key-bindings nil)
  (setq git-commit-summary-max-length 68)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by" "Acked-by" "Modified-by" "Cc"
          "Suggested-by" "Reported-by" "Tested-by" "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line overlong-summary-line))
  (setq magit-diff-refine-hunk t)
  (setq magit-repository-directories '(("~/Code" . 1) ("~" . 1)))
  (define-key magit-diff-section-base-map (kbd "<C-return>") 'magit-diff-visit-file-other-window))
#+end_src

** Eldoc in childframe (eldoc-box.el)
:PROPERTIES:
:CUSTOM_ID: h:93A4474C-DD68-4017-BA27-0E45E369804F
:END:

This package displays ElDoc documentations in a childframe. The childframe is
selectable and scrollable with mouse, even though the cursor is hidden.

#+begin_src emacs-lisp
(use-package eldoc-box :ensure t :after-call flymake-mode)

(with-eval-after-load 'eldoc-box
  (define-key grandview-prog-map (kbd "p") 'eldoc-box-help-at-point))
#+end_src

** Helpful (helpful.el)
:PROPERTIES:
:CUSTOM_ID: h:9B7AA6E6-C7BE-41CD-B523-CB34BB185E0A
:END:

Helpful.el provides a better help buffer. Here are some tweaks I
made for this package and built-in help buffer:

- disable auto jump to other end when cycle through buttons never
- open new window when invoking =helpful-visit-references=.  auto
- focus newly opened help buffer (same behaviour as helpful.el)

#+begin_src emacs-lisp
(use-package helpful :ensure t :after-call meow-keypad-mode-hook)

(define-key global-map (kbd "C-h C-s") 'helpful-symbol)
(define-key global-map (kbd "C-h K") 'describe-keymap)
(define-key global-map (kbd "C-h C-f") 'helpful-callable)
(define-key global-map (kbd "C-h C-v") 'helpful-variable)
(define-key global-map (kbd "C-h k") 'helpful-key)

(with-eval-after-load 'helpful
  (define-key helpful-mode-map (kbd "M-n") (lambda () (interactive) (forward-button 1 nil 1 t)))
  (define-key helpful-mode-map (kbd "M-p") (lambda () (interactive) (backward-button 1 nil 1 t))))
#+end_src

** Emacs Manual (info.el)
:PROPERTIES:
:CUSTOM_ID: h:59DC4309-57FF-4762-8ECC-96826FC36D96
:END:

#+begin_src emacs-lisp
(use-package info :ensure nil)

(with-eval-after-load 'info
  (define-key Info-mode-map (kbd "n") 'next-line)
  (define-key Info-mode-map (kbd "p") 'previous-line)
  (define-key Info-mode-map (kbd "C-n") 'Info-next)
  (define-key Info-mode-map (kbd "C-p") 'Info-prev)
  (define-key Info-mode-map (kbd "s-n") 'forward-paragraph)
  (define-key Info-mode-map (kbd "s-p") 'backward-paragraph))
#+end_src

** Man page (man.el)
:PROPERTIES:
:CUSTOM_ID: h:E15D7EFF-09E4-481B-8B4C-8AE08F46A65E
:END:

#+begin_src emacs-lisp
(use-package man :ensure nil)

(setq Man-notify-method 'newframe)
(with-eval-after-load 'man
  (define-key Man-mode-map (kbd "q") 'kill-this-buffer))
#+end_src

** Ripgrep (rg.el)
:PROPERTIES:
:CUSTOM_ID: h:DCD3F63B-2054-45A3-9579-34B921641468
:END:

A search package based on the ripgrep command line tool.  It allows you to
interactively create searches, doing automatic searches based on the editing
context, refining and modifying search results and much more.  It is also highly
configurable to be able to fit different users' needs.

Some additions I've added to rg transient:

+ =C= key to toggle =--context 3= flag
  show 3 lines of text before and after the keyword
+ =A= key to toggle =-A 5= flag
  like =--context=, but only show text after the keyword
+ press =SPC p p= to search in current project, no ask for confirmation

#+begin_src emacs-lisp
(use-package rg :ensure t :after-call find-file-hook)

(with-eval-after-load 'rg
  (+rg-setup)
  (define-key grandview-prog-map (kbd "s") 'rg-project-all-files-no-ask))
#+end_src

*** Autoload
:PROPERTIES:
:CUSTOM_ID: h:EF6C06C9-5720-41F2-970C-8E221EA70B92
:header-args:emacs-lisp: :tangle "/Users/alex/.cache/emacs/grandview/autoloads/+rg.el"
:END:

The purpose of wrapping =rg-define-toggle/search= is to avoid executing them
immediately, because these macros introduce dependencies that we don't need at
startup.

#+begin_src emacs-lisp
;;;###autoload
(defun +rg-setup ()
  "Define toggles in `rg-mode'."
  (rg-define-toggle "--context 3" (kbd "C"))
  (rg-define-toggle "-A 5" (kbd "A"))
  (rg-define-search rg-project-all-files-no-ask
    :dir project :files "*"))
#+end_src

** Writable grep (wgrep.el)
:PROPERTIES:
:CUSTOM_ID: h:39DE729A-046C-4CD1-B3A5-C807D366061E
:END:

With =wgrep= we can directly edit the results of a grep and save the changes to
all affected buffers.  In principle, this is the same as what the built-in occur
offers.  We can use it to operate on a list of matches by leveraging the full
power of Emacs' editing capabilities (e.g. keyboard macros, query and replace a
regexp .etc).

#+begin_src emacs-lisp
(use-package wgrep :ensure t)

(with-eval-after-load 'wgrep
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t))
#+end_src

** Pdf reader (pdf-tools.el)
:PROPERTIES:
:CUSTOM_ID: h:8F56919D-146C-4EE0-AECF-5512A9B8F571
:END:

#+begin_src emacs-lisp
(use-package pdf-tools :ensure t :after-call doc-view-mode-hook)

(with-eval-after-load 'pdf-tools
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page)
  (setq pdf-annot-activate-created-annotations t) ; automatically annotate highlights
  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0))) ; turn off cua so copy works
  (setq pdf-view-resize-factor 1.1) ; more fine-grained zooming
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
  (define-key pdf-view-mode-map (kbd "t") ''pdf-annot-add-text-annotation)
  (define-key pdf-view-mode-map (kbd "D") ''pdf-annot-delete))
#+end_src

** Epub reader (nov.el)
:PROPERTIES:
:CUSTOM_ID: h:9A0AC633-4FD9-4F1B-9246-023CF0711BA1
:END:

#+begin_src emacs-lisp
(use-package nov :ensure t)
(push '("\\.epub\\'" . nov-mode) auto-mode-alist)
(setq nov-shr-rendering-functions
      '((img . nov-render-img)
        (title . nov-render-title)
        (b . shr-tag-b)))
#+end_src

* About
:PROPERTIES:
:CUSTOM_ID: h:76956BDC-B5A6-49E9-BCE1-0242B5EB647D
:END:

** COPYING
:PROPERTIES:
:CUSTOM_ID: h:3CC0C8EB-75AE-4CDE-803B-A904AD026E65
:END:

#+begin_quote
Copyright (c) 2020-2025 Alex Lu <alexluigit@gmail.com>

This file is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This file is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this file.  If not, see <http://www.gnu.org/licenses/>.
#+end_quote

** File local variables
:PROPERTIES:
:CUSTOM_ID: h:70CB6487-B425-4BE3-8E1B-1FE655056EFC
:END:

Here are the local variables in this file.

+ ~eldoc-documentation-functions~: make eldoc works the same way as in a normal elisp file
+ ~org-edit-src-content-indentation~: do not add spaces at line beginning in src blocks

#+begin_src emacs-lisp
(defun grandview--org-eldoc-funcall (_callback &rest _ignored)
  "Fix `elisp-eldoc-funcall' in `org-mode'."
  (when (eq (org-element-type (org-element-at-point)) 'src-block)
    (let* ((sym-info (elisp--fnsym-in-current-sexp))
           (fn-sym (car sym-info)))
      (when (fboundp fn-sym)
        (message "%s: %s"
                 (propertize (format "%s" fn-sym) 'face 'font-lock-function-name-face)
                 (apply #'elisp-get-fnsym-args-string sym-info))))))

(defun grandview-setup-literate-file ()
  "Setup for `grandview-org-file'."
  (setq-local eldoc-documentation-functions
              '(elisp-eldoc-var-docstring grandview--org-eldoc-funcall))
  (setq-local org-edit-src-content-indentation 0))

(provide 'grandview)
;;; grandview.el ends here
#+end_src

# Local Variables:
# eval: (ignore-errors (grandview-setup-literate-file)))
# End:
