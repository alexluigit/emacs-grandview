#+TITLE: Emacs Configuration
#+AUTHOR: Alex Lu
#+EMAIL: alexluigit@gmail.com
#+PROPERTY: header-args :mkdirp yes

* Overview
** About

This project is my emacs configuration.

*** Structure

+ Init file (init.el / early-init.el)
+ Optimization options (early-optimize.el)
+ Core libraries (core/*, core/autoload/*)
+ extensions (lisp/*)
+ Main config file (ale.org)

doc

#+begin_src emacs-lisp :tangle (ale-minimal-config)
;;; minimal.el --- -*- lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp
;;; full.el --- -*- lexical-binding: t -*-
#+end_src

*** COPYING

Copyright (c) 2020-2021  Alex Lu <alexluigit@gmail.com>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

** Quickstart
*** Dependencies

required:
fd
rg
git
exa
fish
mailcap
words
noto-fonts-emoji
z

optional:
sarasa-gothic
victor-mono-nerd-font
xdotool

*** Install

This section contails instructions on how to use this config.

- Make sure to backup your own emacs config before installation.

#+begin_src shell :tangle no
cp -r ~/.emacs.d ~/.emacs.d.bak
#+end_src

- Clone the repo and tangle the config.

#+begin_src shell :tangle no
git clone https://www.github.com/alexluigit/emacs-grandview
# either put it to ~/.emacs.d
mv ~/emacs-grandview ~/.emacs.d
# or conform XDG spec
mv ~/emacs-grandview ~/.config/emacs/
# or use symlink
mv ~/emacs-grandview ~/Code/emacs-grandview
ln -sf ~/Code/emacs-grandview ~/.config/emacs

# Tangle the config
emacs --daemon
emacsclient -e '(kill-emacs)'
#+end_src

** Restart script

Script for starting up emacs.

+ *Why this bash script?*

  Emacs is a single-threaded program, so if it hangs, we can not
  expect it to evaluate any elisp code.

+ *What does this script do?*

  If this org file get modified, =ale-bootstrap-build= function will tangle
  this file.  After the build function finishes, it kill current emacs
  and open emacs with new init file.

  Since =ale-bootstrap-build= function is added to =kill-emacs-hook=, emacs
  main process only get killed after the tangle function finishes
  (unless we use '-9' flag in kill command).  In my case, it usually
  takes emacs less than 1s to tangle this org file, so if emacs main
  process keep alive for over 3s after ~killall emacs~ command, it
  probably means emacs get frozen, so we just kill it with ~kill -9~.

+ *How to use this script?*

  You don't need to install this script if you have followed
  =Installation= section. This script will be tangled to
  ~~/.local/bin/em~, so if you want to get access to =em restart= command from
  terminal, make sure ~~/.local/bin~ is in your ~$PATH~ environment
  variable.

Here is the content of the script.

#+begin_src bash :tangle "~/.local/bin/em" :shebang "#!/usr/bin/env bash"
restart () {
  notify-send "Restarting emacs..." 2>/dev/null
  emacs_pid=$(pidof emacs)
  timeout=300
  counter=0
  killall emacs
  while $(kill -0 $emacs_pid 2>/dev/null) && [[ $counter -lt $timeout ]]; do
    counter=$((counter + 1))
    sleep 0.01
  done
  kill -9 $emacs_pid 2>/dev/null
  rm -rf ~/.config/emacs/eln-cache 2>/dev/null
  [[ $1 == 1 ]] && rm -rf ~/.cache/emacs/{*.el,straight/build,eln} 2>/dev/null
  emacs --daemon
  command -v xdotool >/dev/null 2>&1 && xdotool set_desktop 0
  emacsclient -cne '(delete-file "~/nohup.out")' >/dev/null 2>&1
}

open () { emacs -nw ${@}; }

[[ -z "$@" ]] || ! $(declare -f -F $1 >/dev/null 2>&1) && { open ${@:1}; exit 0; }
$1 ${@:1}
#+end_src

You can also restart emacs by invoking =restart-emacs= command inside
emacs (again, comfirm your $PATH environment variable).

#+begin_src emacs-lisp
(defun restart-emacs ()
  "A elisp wrapper to `em' command."
  (interactive)
  (let ((default-directory "~"))
    (start-process "" nil "nohup" "em" "restart")))
#+end_src

* Core

Load core of emacs-grandview. It is *NOT* recommend to delete this section.

#+begin_src emacs-lisp
(load (concat ale-init-dir "core/editor.el") nil t)
(load (concat ale-init-dir "core/completion.el") nil t)
(load (concat ale-init-dir "core/ui.el") nil t)
(load (concat ale-init-dir "core/bindings.el") nil t)
#+end_src

* Introspection
** Man page (man.el)

#+begin_src emacs-lisp
(use-package man
  :straight (:type built-in)
  :config
  (setq Man-notify-method 'newframe))
#+end_src

** Emacs Manual (info.el)

#+begin_src emacs-lisp
(use-package info
  :straight (:type built-in)
  :bind
  (:map Info-mode-map
        ("n" . next-line)
        ("p" . previous-line)
        ("C-n" . Info-next)
        ("C-p" . Info-prev)
        ("M-n" . forward-paragraph)
        ("M-p" . backward-paragraph)))
#+end_src

** Helpful (helpful.el)

Helpful.el provides a better help buffer. Here are some tweaks I
made for this package and built-in help buffer:

- disable auto jump to other end when cycle through buttons never
- open new window when invoking =helpful-visit-references=.  auto
- focus newly opened help buffer (same behaviour as helpful.el)

*** Autoload
:PROPERTIES:
:ID:       71d218ce-ec5a-4c50-9b62-f2f351856b3e
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-helpful.el --- -*- lexical-binding: t -*-

(defvar ale/helpful-initialized nil)

;;;###autoload
(defun ale/helpful-mode-hook ()
  ;; FIXME: A better way?
  (setq ale/helpful-initialized nil)
  (advice-add 'find-file :before
              (lambda (&rest _)
                (when (and (not ale/helpful-initialized) (derived-mode-p 'helpful-mode))
                  (switch-to-buffer "*scratch*")
                  (switch-to-prev-buffer)
                  (setq ale/helpful-initialized t))))
  (visual-line-mode))

(provide 'ale-helpful)
#+end_src

*** Config

#+begin_src emacs-lisp
(use-package helpful
  :hook (helpful-mode . ale/helpful-mode-hook)
  :bind
  (("C-h K" . #'describe-keymap)  ; overrides `Info-goto-emacs-key-command-node'
   ([remap describe-function] . #'helpful-callable)
   ([remap describe-symbol] . #'helpful-symbol)
   ([remap describe-key] . #'helpful-key)
   :map helpful-mode-map
   ("M-n" . (lambda () (interactive) (forward-button 1 nil 1 t)))
   ("M-p" . (lambda () (interactive) (backward-button 1 nil 1 t)))))
#+end_src

* Interface
** Window position (transpose-frame.el)

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
(use-package transpose-frame)
#+end_src

** Fill column (visual-fill-column.el)

#+begin_src emacs-lisp
(use-package visual-fill-column)
#+end_src

** Key bindings hint (which-key.el)

#+begin_src emacs-lisp
(use-package which-key
  :init
  (which-key-mode 1 ))
#+end_src

** Buffer list (ibuffer.el)

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.

#+begin_src emacs-lisp
(use-package ibuffer
  :init
  (advice-add 'list-buffers :override 'ibuffer)
  :bind
  (:map ibuffer-mode-map
        ("M-o" . nil)
        ("* f" . ibuffer-mark-by-file-name-regexp)
        ("* g" . ibuffer-mark-by-content-regexp)
        ("* n" . ibuffer-mark-by-name-regexp)
        ("s n" . ibuffer-do-sort-by-alphabetic)
        ("/ g" . ibuffer-filter-by-content))
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-never-show-predicates '("^ \\*.*"))
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " " (name 16 -1) " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook (lambda () (interactive) (hl-line-mode) (ibuffer-update 0))))
#+end_src

* File management
** Find files (files.el)

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package files
  :straight (:type built-in)
  :bind
  (:map ale-files-map
        ("r" . ale/dired-jump))
  :config
  (setq confirm-kill-processes nil)
  (setq ale-files-dot-repo "~/Code/alex.files/")
  (setq ale-files-dir-alist
        '(((title . "  Shows")        (path . "/mnt/HDD/Share/"))
          ((title . "  Coding")       (path . "/mnt/HDD/Dev/"))
          ((title . "  Books")        (path . "/mnt/HDD/Book/"))
          ((title . "輸  Videos")       (path . "/mnt/HDD/Video/"))
          ((title . "  Movies")       (path . "/mnt/Cloud/共享/Movies/"))
          ((title . "  Notes")        (path . "~/Documents/notes/"))
          ((title . "  Photos")       (path . "~/Pictures/"))
          ((title . "  Downloads")    (path . "~/Downloads/")))))
#+end_src

** Dired (dired.el)

=Dired= is a built-in tool that performs file management operations
inside of an Emacs buffer.  It is simply superb!

*** Autoload
:PROPERTIES:
:ID:       2a18e2a0-5b16-4706-b006-884bd4094c4e
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-dired.el --- -*- lexical-binding: t -*-

;;;###autoload
(defun ale/dired-jump () nil)

(defcustom ale/dired-routes '()
  "doc"
  :group 'files :type 'list
  :set
  (lambda (k v)
    `(setq ,k v)
    (eval `(transient-define-prefix ale/dired-jump ()
             ["Go to Directory: "
              ,@(cl-loop for (key desc path) in v
                         collect (list key desc `(lambda () (interactive) (ale-files-find-dir ,path))))]))))

;;;###autoload
(defun ale/dired-rename-space-to-underscore ()
  "Rename current or marked files by replacing space to underscore."
  (interactive)
  (require 'dired-aux)
  (if (or (eq major-mode 'dired-mode)
          (eq major-mode 'danger-mode))
      (let ((markedFiles (dired-get-marked-files )))
        (mapc (lambda (x)
                (when (string-match " " x )
                  (dired-rename-file x (replace-regexp-in-string " " "_" x) nil)))
              markedFiles)
        (if (eq major-mode 'danger-mode)
            (danger-refresh)
          (revert-buffer)))
    (user-error "Not in dired/danger")))

;;;###autoload
(defun ale/dired-file-rename-eol ()
  "Rename current file from end of line."
  (interactive)
  (end-of-line)
  (wdired-change-to-wdired-mode)
  (when (featurep 'meow) (meow-append)))

(provide 'ale-dired)
#+end_src

*** Config

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :custom
  (ale/dired-routes '(("o" "Home"        "~")
                      ("u" "Emacs cache" "~/.cache/emacs")
                      ("p" "Code"        "~/Code")
                      ("n" "Downloads"   "~/Downloads")
                      ("w" "Wallpaper"   "~/Pictures/wallpaper")
                      ("m" "Drives"      "/mnt")
                      ("t" "Trash"       "~/.local/share/Trash")))
  :bind
  (:map dired-mode-map
        ("/" . dired-goto-file)
        ("a" . dired-create-empty-file)
        ("r" . ale/dired-jump)
        ("I" . dired-insert-subdir)
        ("?" . dired-create-directory)
        ("^" . dired-find-file-other-window)
        ("i" . ale/dired-file-rename-eol)
        ("d" . dired-kill-subdir)
        ("<" . beginning-of-buffer)
        (">" . end-of-buffer)
        ("[" . dired-prev-dirline)
        ("]" . dired-next-dirline)
        ("o" . dired-up-directory)
        ("x" . dired-do-delete)
        ("." . dired-omit-mode)
        ("% SPC" . ale/dired-rename-space-to-underscore))
  :config
  (setq large-file-warning-threshold 50000000)
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-listing-switches "-AGhlv --group-directories-first --time-style=long-iso"))
#+end_src

** Writable dired (wdired.el)

#+begin_src emacs-lisp
(use-package wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+end_src

** Project management (project.el)

#+begin_src emacs-lisp
(use-package project
  :straight (:type built-in)
  :config
  (setq project-switch-commands
        '((project-find-file "File" ?\r)
          (ale-project-find-subdir "Subdir" ?s)
          (project-find-regexp "Grep" ?g)
          (project-dired "Dired" ?d)
          (ale-project-retrieve-tag "Tag switch" ?t)
          (ale-project-magit-status "Magit" ?m)
          (ale-project-commit-log "Log VC" ?l)))
  (setq ale-project-commit-log-limit 25)
  :bind
  (:map project-prefix-map
        ("l" . ale-project-commit-log)
        ("m" . ale-project-magit-status)
        ("s" . ale-project-find-subdir)
        ("t" . ale-project-retrieve-tag)))
#+end_src

** A better dired interface (danger.el)

This package is inspired the popular file manager =ranger=, I created it
on the basis of =ranger.el=. Compare to =ranger.el=, this package only
keeps features I wanted, and some sensible functionalities were added
as well. See details at: https://github.com/alexluigit/danger.el

#+begin_src emacs-lisp
(use-package danger
  :after-call pre-command-hook
  :straight (danger :type git :depth full :host github :repo "alexluigit/danger.el")
  :bind
  (:map meow-leader-keymap ("n" . danger))
  :hook
  (danger-mode . (lambda () (setq cursor-type nil) (setq mode-line-format nil)))
  :config
  (danger-override-dired-mode)
  (danger-minibuf-preview-mode)
  (setq danger-trash-dir-alist '(("/mnt/HDD/" . ".Trash/files")
                                 ("/mnt/Cloud/" . ".Trash/files"))))
#+end_src

** Dired mode highlighting (diredfl.el)

Additional syntax highlighting in dired buffer.

#+begin_src emacs-lisp
(use-package diredfl
  :hook (dired-mode . diredfl-mode))
#+end_src

** Trash (trashed.el)

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(use-package trashed
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

* Text Editing
** Parentheses (paren.el / rainbow-delimiters.el)

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.
- Use rainbow color for delimiters

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package paren
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  :hook
  (after-init . show-paren-mode))

(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+end_src

** Prettify symbols (prog-mode.el)

#+begin_src emacs-lisp
(use-package prog-mode
  :straight nil
  :hook (prog-mode . prettify-symbols-mode)
  :config
  (setq-default prettify-symbols-alist
                '(("lambda" . ?λ)
                  ("<-" . ?←)
                  ("->" . ?→)
                  ("->>" . ?↠)
                  ("=>" . ?⇒)
                  ("/=" . ?≠)
                  ("!=" . ?≠)
                  ("==" . ?≡)
                  ("<=" . ?≤)
                  (">=" . ?≥)
                  ("=<<" . (?= (Br . Bl) ?≪))
                  (">>=" . (?≫ (Br . Bl) ?=))
                  ("<=<" . ?↢)
                  (">=>" . ?↣)))
  (setq prettify-symbols-unprettify-at-point 'right-edge))
#+end_src

** Regular expressions (re-builder.el)

To learn more about regular expressions, read the relevant pages in
the official manual.  Assuming you have this installed properly on
your system, run =C-h r i regexp= to get to the starting chapter.

Emacs offers a built-in package for practising regular expressions.
By default, =re-builder= uses Emacs-style escape notation, in the form
of double backslashes.  You can switch between the various styles by
using =C-c TAB= inside of the regexp builder's buffer.  I choose to keep
this style as the default.  Other options are =string= and =rx=.

#+begin_src emacs-lisp
(use-package re-builder
  :config
  (setq reb-re-syntax 'read))
#+end_src

** Ripgrep (rg.el)

#+begin_src emacs-lisp
(defun ale/rg-config ()
  (rg-define-toggle "--context 3" (kbd "C"))
  (rg-define-toggle "-A 5" (kbd "A")))

(use-package rg
  :config
  ;;; XXX nasty hack for lazy loading
  (ale/rg-config)
  :bind
  (:map ale-utils-map
        ("r" . rg)))
#+end_src

* Languages
** .rs

#+begin_src emacs-lisp
(use-package rust-mode
  :hook
  (rust-mode . (lambda () (setq indent-tabs-mode nil))))
#+end_src

** .lua

#+begin_src emacs-lisp
(use-package lua-mode
  :config
  (setq lua-indent-level 2))
#+end_src

** .yaml

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package yaml-mode)
#+end_src

** .vue

#+begin_src emacs-lisp
(use-package web-mode
  :config
  (define-derived-mode ale/vue-mode web-mode "ale/vue"
    "A major mode derived from web-mode, for editing .vue files with LSP support.")
  :hook
  (web-mode . (lambda ()
                (setq web-mode-markup-indent-offset 2)
                (setq web-mode-code-indent-offset 2)
                (setq web-mode-script-padding 0)))
  :mode ("\\.vue\\'" . ale/vue-mode))
#+end_src

** .js

#+begin_src emacs-lisp
(use-package js
  :straight (:type built-in)
  :config
  (setq js-indent-level 2))
#+end_src

** .(sh|zsh)

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package sh-script
  :straight (:type built-in)
  :config
  (setq sh-basic-offset 2))
#+end_src

* DevTools
** LSP (lsp.el)
*** Autoload
:PROPERTIES:
:ID:       956309f4-61ce-4489-922d-a8343f281101
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-lsp.el --- -*- lexical-binding: t -*-

(defun ale/lsp--inhibit ()
  "Disable `lsp-deferred' in minibuffer."
  (advice-add 'lsp-deferred :override #'ignore))

(defun ale/lsp--recover ()
  "Recover `lsp-deferred' after quit minibuffer."
  (advice-remove 'lsp-deferred #'ignore))

;;;###autoload
(define-minor-mode ale/lsp-mode
  "Inhibit lsp in minibuffer."
  :init-value nil
  :global t
  (if ale/lsp-mode
      (progn
      (add-hook 'minibuffer-setup-hook 'ale/lsp--inhibit)
      (add-hook 'minibuffer-exit-hook 'ale/lsp--recover))
    (progn
      (remove-hook 'minibuffer-setup-hook 'ale/lsp--inhibit)
      (remove-hook 'minibuffer-exit-hook 'ale/lsp--recover))))

(provide 'ale-lsp)
#+end_src

*** Config

#+begin_src emacs-lisp
(use-package lsp-mode
  :after-call pre-command-hook
  :hook ((sh-mode
          lua-mode
          ale/vue-mode
          typescript-mode
          rust-mode)
         . lsp-deferred)
  :config
  (ale/lsp-mode)
  (setq lsp-eldoc-hook nil)
  (setq lsp-server-install-dir (expand-file-name (concat user-emacs-directory "lsp")))
  (add-to-list 'warning-suppress-types '(lsp-mode))
  (lsp-register-custom-settings '(("vetur.ignoreProjectWarning" t t)))
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols)))
#+end_src

*** Extensions

#+begin_src emacs-lisp
(use-package lsp-tailwindcss
  :after (lsp-mode web-mode)
  :init
  (setq lsp-tailwindcss-add-on-mode t))

(use-package lsp-ui
  :after-call lsp-deferred
  :config
  (setq lsp-ui-sideline-show-code-actions nil)
  (setq lsp-ui-doc-position 'bottom)
  :hook
  (lsp-mode . lsp-ui-mode))

(use-package lsp-treemacs)
#+end_src

** Colorizer (rainbow-mode.el)

#+begin_src emacs-lisp
(use-package rainbow-mode
  :hook
  (prog-mode . rainbow-mode))
#+end_src

** Formatter (format-all.el)

#+begin_src emacs-lisp
(use-package format-all
  :bind ("C-c C-M-f" . format-all-buffer))
#+end_src

** Syntax checker (flymake.el)

#+begin_src emacs-lisp
(use-package flymake
  :straight (:type built-in)
  :config
  (setq elisp-flymake-byte-compile-load-path
        (append elisp-flymake-byte-compile-load-path load-path))
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  :bind
  (:map flymake-mode-map
  ("C-c ! s" . flymake-start)
  ("C-c ! d" . flymake-show-diagnostics-buffer)
  ("C-c ! n" . flymake-goto-next-error)
  ("C-c ! p" . flymake-goto-prev-error)))
#+end_src

** Snippet (yasnippet.el)

#+begin_src emacs-lisp
(use-package yasnippet
  :after-call self-insert-command
  :config
  (yas-global-mode))
#+end_src

** COMMENT REST client (restclient.el)

#+begin_src emacs-lisp
(use-package restclient)
#+end_src

** COMMENT Scratch buffers (scratch.el)
This package will produce a buffer that matches the major mode of the
one you are currently in.  Use it with =M-x scratch=.  Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead.  Simple yet
super effective!

The =ale/scratch-buffer-setup= simply adds some text in the buffer and
renames it appropriately for the sake of easier discovery.  I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(use-package scratch
  :config
  (defun ale/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
    (let* ((mode major-mode)
           (string (format "Scratch buffer for: %s\n\n" mode))
           (region (with-current-buffer (current-buffer)
                     (if (region-active-p)
                         (buffer-substring-no-properties
                          (region-beginning)
                          (region-end)))
                     ""))
           (text (concat string region)))
      (when scratch-buffer
        (save-excursion
          (insert text)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
        (forward-line 2))
      (rename-buffer (format "*Scratch for %s*" mode) t)))
  (add-hook 'scratch-create-buffer-hook #'ale/scratch-buffer-setup)
  (define-key global-map (kbd "C-c s") #'scratch))
#+end_src

* Terminal
** Vterm (vterm.el)
*** Autoload
:PROPERTIES:
:ID:       76cafb17-37ee-40c4-bf9f-6721d5f825bf
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-vterm.el --- -*- lexical-binding: t -*-

(defcustom ale/vterm-position
  '((danger-mode . ((window-height . 0.4) (side . bottom)))
    (default . ((window-width . 0.4) (side . right))))
  "doc")

(defvar ale/vterm-buffers nil
  "The list of non-dedicated vterm buffers.")

(defvar ale/vterm-index 0
  "The index of current vterm buffer.")

(add-hook 'kill-buffer-hook
          (lambda ()
            (let* ((buf (current-buffer))
                   (name (buffer-name buf)))
              (when (string-prefix-p "*vterm" name)
                (delq! buf ale/vterm-buffers)))))

;;;###autoload
(defun ale/vterm--disable-side-window (fn &rest args)
  "Prevent vterm size adjust break selection."
  (unless (and (region-active-p)
               (derived-mode-p 'vterm-mode))
    (apply fn args)))

;;;###autoload
(advice-add 'display-buffer-in-side-window :around 'ale/vterm--disable-side-window)

;;;###autoload
(defun vterm-send-C-delete ()
  (interactive)
  (vterm-send-key "<delete>" nil nil 0))

;;;###autoload
(defun vterm-send-M-return ()
  (interactive)
  (vterm-send-escape)
  (vterm-send-return))

;;;###autoload
(defun vterm-send-M-/ ()
  (interactive)
  (vterm-send-key "/" nil 0 nil))

;;;###autoload
(defun vterm-send-F5 ()
  (interactive)
  (vterm-send-key "<f5>" nil nil nil))

;;;###autoload
(defun vterm-send-M-apostrophe ()
  (interactive)
  (vterm-send-key "'" nil 0 nil))

;;;###autoload
(defun vterm-send-M-quote ()
  (interactive)
  (vterm-send-key "\"" nil 0 nil))

(defun ale/vterm--get-win-params ()
  "Parse `ale/vterm-position' to get vterm display parameters."
  (let (pos)
    (cl-dolist (setting ale/vterm-position)
        (when (derived-mode-p (car setting))
          (setq pos (cdr setting)) (cl-return))
        (when (eq (car setting) 'default)
          (setq pos (cdr setting))))
    `(("^\\*vterm.*"
       (display-buffer-in-side-window)
       (window-parameters . ((mode-line-format . none)))
       ,@pos))))

;;;###autoload
(defun ale/vterm-toggle (&optional force)
  "Toggle vterm.
If called with prefix argument, create a new vterm buffer if
current one have different `default-directory'."
  (interactive "P")
  (if (eq major-mode 'vterm-mode)
      (delete-window)
    (let* ((display-buffer-alist (ale/vterm--get-win-params))
           (buf (nth ale/vterm-index ale/vterm-buffers))
           (dir (expand-file-name default-directory))
           (index (if buf (ale/vterm--get-index buf) 0)))
      (add-to-list 'ale/vterm-buffers (vterm index))
      (when force
        (unless (string= dir (expand-file-name default-directory))
          (let ((default-directory dir))
            (ale/vterm-new))))
      (ale/vterm--insert))))

(defun ale/vterm--get-index (buf)
  (let* ((name (buffer-name buf)))
    (string-match "\\*vterm\\*\<\\([0-9]+\\)\>" name)
    (string-to-number (cl-subseq name (match-beginning 1) (match-end 1)))))

(defun ale/vterm--insert ()
  (when (featurep 'evil) (evil-insert-state))
  (when (featurep 'meow) (meow-insert)))

;;;###autoload
(defun ale/vterm-new ()
  "Create new vterm buffer."
  (interactive)
  (let ((new-index (1+ (ale/vterm--get-index (car ale/vterm-buffers))))
        (display-buffer-alist (ale/vterm--get-win-params)))
    (add-to-list 'ale/vterm-buffers (vterm new-index))
    (ale/vterm--insert)))

;;;###autoload
(defun ale/vterm-next (&optional arg)
  "Select next vterm buffer.
Create new one if no vterm buffer exists."
  (interactive "P")
  (let* ((curr-index (cl-position (current-buffer) ale/vterm-buffers))
         (new-index (+ curr-index (or arg -1)))
         (buf (nth new-index ale/vterm-buffers)))
    (when buf
      (switch-to-buffer buf)
      (setq ale/vterm-index new-index))))

;;;###autoload
(defun ale/vterm-prev (&optional arg)
  "Select previous vterm buffer."
  (interactive "p")
  (ale/vterm-next arg))

(provide 'ale-vterm)
#+end_src

*** Config

#+begin_src emacs-lisp
(use-package vterm
  :config
  (setq vterm-max-scrollback 5000)
  (set-face-attribute 'vterm-color-white nil :foreground "#cccccc")
  (set-face-attribute 'vterm-color-black nil :foreground "#111111")
  :bind
  (("M-v" . ale/vterm-toggle)
   :map vterm-mode-map
   ("M-v" . ale/vterm-toggle)
   ("<f12>" . ale/vterm-new)
   ("M-'" . vterm-send-M-apostrophe)
   ("M-\"" . vterm-send-M-quote)
   ("M-/" . vterm-send-M-/)
   ("M-RET" . vterm-send-M-return)
   ("s-n" . vterm-next-prompt)
   ("s-p" . vterm-previous-prompt)
   ("M-." . ale/vterm-next)
   ("M-," . ale/vterm-prev)
   ("S-<escape>" . (lambda () (interactive) (meow-normal-mode) (meow--update-cursor)))
   ("C-<delete>" . vterm-send-C-delete)
   ("C-<return>" . vterm-send-F5)))
#+end_src

** COMMENT Eshell (eshell.el)
*** Autoload
:PROPERTIES:
:ID:       05d50f67-511f-483d-ba45-50d374f3f5cb
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-eshell.el --- -*- lexical-binding: t -*-

(require 'em-hist)
(eval-when-compile (require 'subr-x))
(require 'cl-seq)

(defcustom ale/eshell-position
  '((danger-mode . ((window-height . 0.4) (side . bottom)))
    (default . ((window-width . 0.4) (side . right))))
  "doc")

(defvar ale/eshell-buffers nil
  "The list of non-dedicated eshell buffers.")

(defvar ale/eshell-index 0
  "The index of current eshell buffer.")

(defun ale/get-current-package-version ()
  (interactive)
  (let ((package-json-file (concat (eshell/pwd) "/package.json")))
    (when (file-exists-p package-json-file)
      (let* ((package-json-contents (ale-f-read package-json-file))
             (package-json (ignore-errors (json-parse-string package-json-contents))))
        (when package-json
          (ignore-errors (gethash "version" package-json)))))))

(defun ale/map-line-to-status-char (line)
  (cond ((string-match "^?\\? " line) "?")))

(defun ale/get-git-status-prompt ()
  (let ((status-lines (cdr (process-lines "git" "status" "--porcelain" "-b"))))
    (seq-uniq (seq-filter 'identity (mapcar 'ale/map-line-to-status-char status-lines)))))

(defun ale/get-prompt-path ()
  (let* ((current-path (eshell/pwd))
         (git-output (shell-command-to-string "git rev-parse --show-toplevel"))
         (has-path (not (string-match "^fatal" git-output))))
    (if (not has-path)
        (abbreviate-file-name current-path)
      (string-remove-prefix (file-name-directory git-output) current-path))))

;; This prompt function mostly replicates my custom zsh prompt setup
(defun ale/eshell-prompt ()
  (let* ((br-cmd "git symbolic-ref HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null")
         (br-raw (shell-command-to-string br-cmd))
         (current-branch (replace-regexp-in-string "\\(refs/heads/\\)\\|\\(\n\\)$" "" br-raw))
         (shell-index (number-to-string (ale/eshell-get--index (current-buffer))))
         (package-version (ale/get-current-package-version)))
    (concat
     (if (= (user-uid) 0)
         (propertize (concat "S-" shell-index) 'face `(:foreground "red2"))
       (propertize (concat "S-" shell-index) 'face `(:foreground "#62aeed")))
     (propertize " • " 'face `(:foreground "white"))
     (propertize "  " 'face `(:foreground "#82cfd3"))
     (propertize (ale/get-prompt-path) 'face `(:foreground "#82cfd3"))
     (when (not (string= current-branch ""))
       (concat
        (propertize " • " 'face `(:foreground "white"))
        (propertize (concat " " current-branch) 'face `(:foreground "#ab98b5"))))
     (when package-version
       (concat
        (propertize " @ " 'face `(:foreground "white"))
        (propertize package-version 'face `(:foreground "#e8a206"))))
     (propertize " • " 'face `(:foreground "white"))
     (propertize (format-time-string "%I:%M:%S %p") 'face `(:foreground "#5a5b7f"))
     (if (= eshell-last-command-status 0)
         (propertize "\nλ" 'face `(:foreground "#ADCF44"))
       (propertize "\nλ" 'face `(:foreground "#EC6261")))
     (propertize " " 'face `(:foreground "white")))))

;;;###autoload
(defun ale/eshell-init ()
  (push 'eshell-tramp eshell-modules-list)
  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
  (define-key eshell-hist-mode-map (kbd "M-r") 'consult-history)
  ;; Initialize the shell history
  (eshell-hist-initialize)
  (setenv "PAGER" "cat")
  (setq eshell-prompt-function      'ale/eshell-prompt)
  (setq eshell-prompt-regexp        "^λ ")
  (setq eshell-history-size         10000)
  (setq eshell-buffer-maximum-lines 10000)
  (setq eshell-hist-ignoredups t)
  (setq eshell-highlight-prompt t)
  (setq eshell-scroll-to-bottom-on-input t)
  (setq eshell-prefer-lisp-functions nil))

(add-hook 'eshell-exit-hook
          (lambda () (setq ale/eshell-buffers (delq (current-buffer) ale/eshell-buffers))))

;;;###autoload
(defun ale/eshell-updir ()
  "Up a directory in eshell."
  (interactive)
  (eshell/cd "..")
  (eshell-emit-prompt))

(defun ale/eshell--get-win-params ()
  "Parse `ale/eshell-position' to get eshell display parameters."
  (let (pos)
    (cl-dolist (setting ale/eshell-position)
        (when (derived-mode-p (car setting))
          (setq pos (cdr setting)) (cl-return))
        (when (eq (car setting) 'default)
          (setq pos (cdr setting))))
    `(("^\\*[e]shell.*"
       (display-buffer-in-side-window)
       (window-parameters . ((mode-line-format . none)))
       ,@pos))))

;;;###autoload
(defun ale/eshell-toggle (&optional force-new)
  "Toggle eshell.
If called with prefix argument, create a new eshell buffer if
current one have different `default-directory'."
  (interactive "P")
  (if (eq major-mode 'eshell-mode)
      (delete-window)
    (let* ((display-buffer-alist (ale/eshell--get-win-params))
           (buf (nth ale/eshell-index ale/eshell-buffers))
           (dir (expand-file-name default-directory))
           (index (if buf (ale/eshell-get--index buf) 0)))
      (add-to-list 'ale/eshell-buffers (eshell index))
      (when force-new
        (unless (string= dir (expand-file-name default-directory))
          (let ((default-directory dir))
            (ale/eshell-new))))
      (when (featurep 'evil) (evil-insert-state))
      (when (featurep 'meow) (meow-insert)))))

(defun ale/eshell-get--index (buf)
  (let* ((name (buffer-name buf)))
    (string-match "\\*eshell\\*\<\\([0-9]+\\)\>" name)
    (string-to-number (cl-subseq name (match-beginning 1) (match-end 1)))))

;;;###autoload
(defun ale/eshell-new ()
  "Create new eshell buffer."
  (interactive)
  (let ((new-index (1+ (ale/eshell-get--index (car ale/eshell-buffers))))
        (display-buffer-alist (ale/eshell--get-win-params)))
    (add-to-list 'ale/eshell-buffers (eshell new-index))
    (when (featurep 'evil) (evil-insert-state))
    (when (featurep 'meow) (meow-insert))))

;;;###autoload
(defun ale/eshell-next (&optional arg)
  "Select next eshell buffer.
Create new one if no eshell buffer exists."
  (interactive "P")
  (let* ((curr-index (cl-position (current-buffer) ale/eshell-buffers))
         (new-index (+ curr-index (or arg -1)))
         (buf (nth new-index ale/eshell-buffers)))
    (when buf
      (switch-to-buffer buf)
      (setq ale/eshell-index new-index))))

;;;###autoload
(defun ale/eshell-prev (&optional arg)
  "Select previous eshell buffer."
  (interactive "p")
  (ale/eshell-next arg))

;;;###autoload
(defun ale/eshell-clear-buffer ()
  "Clear eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input nil nil t)))

(provide 'ale-eshell)
#+end_src

*** Multi-eshell

A poor man's multi-eshell.

#+begin_src emacs-lisp
(use-package esh-mode
  :straight (:type built-in)
  :config
  (setq eshell-banner-message "")
  :hook
  (eshell-first-time-mode . ale/eshell-init)
  :bind
  (("<delete>" . ale/eshell-toggle)
   ("<deletechar>" . ale/eshell-toggle)
   :map eshell-mode-map
   ("M-<delete>" . ale/eshell-new)
   ("C-l" . ale/eshell-clear-buffer)
   ("C-\\" . ale/eshell-updir)
   ("s-n" . eshell-next-prompt)
   ("s-p" . eshell-previous-prompt)
   ("M-." . ale/eshell-next)
   ("M-," . ale/eshell-prev)))
#+end_src

*** Aliases

This section will be tangled to `eshell-aliases-file'.

#+begin_src conf :tangle (concat user-emacs-directory "eshell/alias")
alias e find-file-other-window $1
alias ls exa -a --color=always --group-directories-first $*
alias la exa -al --color=always --group-directories-first $*
alias ll exa -lu --color=always --group-directories-first --no-user --no-permissions -@ $*
alias lt exa -aT --color=always --git-ignore -I=.git --group-directories-first $*
alias ka killall $1
alias px export HTTP_PROXY=http://127.0.0.1:1088; export HTTPS_PROXY=http://127.0.0.1:1088
alias yd youtube-dl --proxy 127.0.0.1:1088 --write-sub --write-auto-sub -o "~/Downloads/%(title)s-%(id)s.%(ext)s" $1
alias ydl youtube-dl --proxy 127.0.0.1:1088 --yes-playlist --write-sub --write-auto-sub -o "~/Downloads/%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s" $1
alias y yarn $*
alias ys yarn dev
alias rs rsync $*
alias rsa rsync -avz $*
#+end_src

*** Colors (xterm-color.el)

We want to use xterm-256color when running interactive commands in eshell but
not during other times when we might be launching a shell command to gather its
output.

#+begin_src emacs-lisp
(use-package xterm-color
  :after esh-mode
  :config
  (push 'xterm-color-filter eshell-preoutput-filter-functions)
  (add-hook 'eshell-pre-command-hook (lambda () (setenv "TERM" "xterm-256color")))
  (add-hook 'eshell-post-command-hook (lambda () (setenv "TERM" "dumb")))
  (add-hook 'eshell-before-prompt-hook (lambda () (setq xterm-color-preserve-properties t)))
  (delq 'eshell-handle-ansi-color eshell-output-filter-functions))
#+end_src

*** Fish like Completion (fish-completion.el)

This enhances eshell's completions with those that Fish is capable of and also
falls back to any additional completions that are configured for Bash on the
system.  The primary benefit here (for me) is getting completion for commits and
branches in =git= commands.

#+begin_src emacs-lisp
(use-package fish-completion
  :hook (eshell-mode . fish-completion-mode))
#+end_src

*** Z navigation (eshell-z.el)

#+begin_src emacs-lisp
(use-package eshell-z
  :hook ((eshell-first-time-mode . (lambda () (require 'eshell-z)))
         (eshell-z-change-dir .  (lambda () (eshell/pushd (eshell/pwd))))))
#+end_src

*** Highlighting (eshell-syntax-highlighting.el)

#+begin_src emacs-lisp
(use-package eshell-syntax-highlighting
  :after esh-mode
  :config
  (eshell-syntax-highlighting-global-mode +1))
#+end_src

*** History completion (esh-autosuggest.el)

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode)
  :bind
  (:map esh-autosuggest-active-map
        ("M-f" . esh-autosuggest-complete-word)
        ("C-e" . company-complete-selection))
  :config
  (set-face-foreground 'company-preview-common "#4b5668")
  (set-face-background 'company-preview nil))
#+end_src

* Version control
** Built-in vc config

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package vc-hooks
  :straight (:type built-in)
  :config
  ;; No ask for follow symlink
  (setq vc-follow-symlinks t))
#+end_src

** Git porcelain (magit.el)

#+begin_src emacs-lisp
(use-package magit
  :config
  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-define-global-key-bindings nil)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))
  (setq magit-diff-refine-hunk t)
  (setq magit-repository-directories
        '(("~/Code" . 1) ("~" . 1)))
  :bind (("C-M-g" . magit-status-here)
         :map magit-mode-map
         ("q" . kill-this-buffer)
         ("`" . magit-diff-show-or-scroll-up)
         :map magit-diff-section-base-map
         ("<C-return>" . magit-diff-visit-file-other-window)
         :map magit-diff-mode-map
         ("`" . scroll-up)))
#+end_src

** Hunk indicator (git-gutter.el)

#+begin_src emacs-lisp
(use-package git-gutter
  :config
  (custom-set-variables
   '(git-gutter:modified-sign "⏽")
   '(git-gutter:added-sign "⏽")
   '(git-gutter:deleted-sign "⏽")))
#+end_src

** Resolve conflict (ediff.el)

#+begin_src emacs-lisp
(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< ale-ediff-combine Variant A" A
          ">>>>>>> ale-ediff-combine Variant B" B
          "####### ale-ediff-combine Ancestor" Ancestor
          "======= ale-ediff-combine End"))
  (defun ale/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.
This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*ale-ediff.*" (point-min) (point-max) nil)))
#+end_src

** COMMENT Forges (forge.el)

#+begin_src emacs-lisp
(use-package forge)
#+end_src

* Org mode
** Org (org.el)

In its purest form, Org is a markup language that is similar to
Markdown: symbols are used to denote the meaning of a construct in its
context, such as what may represent a headline element or a phrase that
calls for emphasis.

What lends Org its super powers though is everything else built around
it: a rich corpus of Elisp functions that automate, link, combine,
enhance, structure, or otherwise enrich the process of using this rather
straightforward system of plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and
workflows on how to organise one's life with plain text.

This section is all about basic configurations for Org-mode which
contains several subsections as follows:

- How a =.org= file should look like
- Basic bhhaviour of headings
- Basic behaviour of source block

#+begin_src emacs-lisp
(use-package org
  :straight (:type built-in)
  :hook
  (org-mode . ale-org-font-setup)
  (org-tab-first . org-end-of-line)
  :config
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars t)
  (setq org-startup-folded t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-ellipsis " ▾")
  (setq org-hide-emphasis-markers t)
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  :bind
  (:map org-mode-map
        ("C-c S-l" . org-toggle-link-display)
        ("C-c C-S-l" . org-insert-last-stored-link)))
#+end_src

** Source block

#+begin_src emacs-lisp
(use-package org-src
  :straight (:type built-in)
  :after-call org-mode
  :config
  (push '("conf-unix" . conf-unix) org-src-lang-modes)
  (setq org-edit-src-content-indentation 0)
  (setq org-src-window-setup 'split-window-right))

(use-package org-tempo ; this is needed as of Org 9.2
  :straight (:type built-in)
  :after-call org-mode
  :config
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("hk" . "src haskell"))
  (add-to-list 'org-structure-template-alist '("py" . "src python")))

;; Tricks for lazy loading.
;; Thanks to: https://blog.d46.us/advanced-emacs-startup/
(use-package ob-python
  :straight (:type built-in)
  :commands (org-babel-execute:python))

(use-package ob-shell
  :straight (:type built-in)
  :commands
  (org-babel-execute:shell))
#+end_src

** Bullet (org-superstar.el)

#+begin_src emacs-lisp
(use-package org-superstar
  :config
  (setq org-superstar-item-bullet-alist '((?* . ?•) (?+ . ?+) (?- . ?•)))
  (setq org-superstar-remove-leading-stars t)
  (setq org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●"))
  :hook
  (org-mode . org-superstar-mode))
#+end_src

** Habit (org-habit.el)

#+begin_src emacs-lisp
(use-package org-habit
  :straight nil
  :config
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60))
#+end_src

** Wiki (org-roam.el)

#+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-id-link-to-org-use-id t)
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory (file-truename "~/Documents/roam"))
  (org-roam-completion-everywhere t)
  :bind
  (:map ale-org-map
        ("l" . org-roam-buffer-toggle)
        ("f" . org-roam-node-find)
        ("g" . org-roam-graph)
        ("i" . org-roam-node-insert)
        ("c" . org-roam-capture)
        ("j" . org-roam-dailies-capture-today))
  :config
  (org-roam-setup))
#+end_src

* Media
** Video url (ale-murl.el)
*** Autoload
:PROPERTIES:
:ID:       48f13168-7c74-4676-881a-b6f666eec120
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-murl.el -*- lexical-binding: t; -*-

(require 'json)

(defvar ale/murl-list-file (expand-file-name "~/.cache/murl/main_list.json"))

(defun ale/murl--playlist ()
  (append (json-read-file ale/murl-list-file) nil))

(defun ale/murl--get-attr (title attr)
  (cl-dolist (i (ale/murl--playlist))
    (when (string= title (cdr (assq 'title i)))
      (cl-return (cdr (assq attr i))))))

;;;###autoload
(defun ale/murl-open (&optional no-hist)
  "Select video or stream to play in mpv."
  (interactive "P")
  (unless no-hist
    (let* ((clip (condition-case nil (current-kill 0 t) (error ""))))
      (set-text-properties 0 (length clip) nil clip)
      (when-let* ((is-url (string-prefix-p "http" clip))
                  (json (shell-command-to-string (concat "murl -P 1088 json '" clip "'")))
                  (valid (string-prefix-p "{" json))
                  (obj (json-read-from-string json))
                  (playlist (ale/murl--playlist)))
        (cl-pushnew obj playlist :test 'equal)
        (with-temp-buffer
          (insert (json-encode (vconcat playlist)))
          (json-pretty-print-buffer)
          (write-region (point-min) (point-max) ale/murl-list-file)))))
  (let* ((cands-raw (mapcar (lambda (i) (cdr (assq 'title i))) (ale/murl--playlist)))
         (annotation (lambda (s) (marginalia--documentation (ale/murl--get-attr s 'url))))
         (cands (ale-minibuffer-append-metadata annotation cands-raw))
         (title (completing-read "murls: " cands))
         (sub (ale/murl--get-attr title 'sub)))
    (call-process "murl" nil 0 nil "-r" "-f" "-P" "1088" "-s" sub (ale/murl--get-attr title 'url))))

(provide 'ale-murl)
#+end_src

*** Config

#+begin_src emacs-lisp
(bind-keys
 :map ale-utils-map
 ("m" . ale/murl-open))
#+end_src

** Pdf reader (pdf-tools.el)

#+begin_src emacs-lisp
(use-package pdf-tools
  :after-call find-file-hook
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t)
  ;; turn off cua so copy works
  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
  ;; more fine-grained zooming
  (setq pdf-view-resize-factor 1.1)
  ;; keyboard shortcuts
  :bind
  (:map pdf-view-mode-map
  ("C-s" . isearch-forward)
  ("h" . pdf-annot-add-highlight-markup-annotation)
  ("t" . 'pdf-annot-add-text-annotation)
  ("D" . 'pdf-annot-delete)))
#+end_src

** Epub reader (nov.el)

#+begin_src emacs-lisp
(use-package shrface
  :after nov
  :config
  (shrface-basic)
  (shrface-trial)
  (add-to-list 'shr-external-rendering-functions
               '(span . shrface-tag-span))
  (shrface-default-keybindings) ; setup default keybindings
  (setq shrface-href-versatile t))

(use-package nov
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (add-hook 'nov-mode-hook 'ale/nov-setup)
  :config
  (advice-add 'nov-render-title :override #'ignore)
  (setq nov-shr-rendering-functions '((img . nov-render-img)
                                      (title . nov-render-title)
                                      (b . shr-tag-b)))
  (setq nov-shr-rendering-functions
        (append nov-shr-rendering-functions
                shr-external-rendering-functions))
  (defun ale/nov-setup ()
    (require 'shrface)
    (shrface-mode)))
#+end_src
** COMMENT Music Player (netease-cloud-music.el)

#+begin_src emacs-lisp
(use-package netease-cloud-music
  :straight (:host github :repo "SpringHan/netease-cloud-music.el"))
#+end_src

* Applications
** Dictionary (fanyi.el)

#+begin_src emacs-lisp
(use-package fanyi
  :bind
  (:map ale-utils-map
        ("t" . fanyi-dwim))
  :custom
  (fanyi-providers '(fanyi-etymon-provider
                     fanyi-longman-provider)))
#+end_src

** Emacs application framework (eaf.el)

#+begin_src emacs-lisp
(use-package eaf
  :demand t
  :straight
  (emacs-application-framework
   :host github
   :repo "emacs-eaf/emacs-application-framework"
   :files ("*")
   :pre-build (("sed" "-i" "s/yay/paru/g" "./install-eaf.py") ; use paru rather than yay
               ("./install-eaf.py" "--install-core-deps" "--install" "browser" "image-viewer")
               ("git" "checkout" ".") ; revert all the changes we made
               ("rm" "-rf" "~/.npm")))
  :init
  (let ((default-directory (concat (straight--build-dir) "emacs-application-framework/app/")))
    (normal-top-level-add-subdirs-to-load-path))
  :config
  (setq eaf-proxy-type "http")
  (setq eaf-proxy-host "127.0.0.1")
  (setq eaf-proxy-port "1088")
  (define-key key-translation-map (kbd "SPC")
    (lambda (prompt)
      (if (derived-mode-p 'eaf-mode)
          (pcase eaf--buffer-app-name
            ("browser" (if (string= (eaf-call-sync "call_function" eaf--buffer-id "is_focus") "True")
                           (kbd "SPC")
                         (kbd ale-local-leader-key)))
            (_  (kbd ale-local-leader-key)))
        (kbd "SPC")))))

(use-package eaf-browser
  :straight nil
  :after-call pre-command-hook
  :config
  (setq eaf-browser-default-zoom 1.5)
  (eaf-bind-key nil "M-o" eaf-browser-keybinding)
  (eaf-bind-key insert_or_scroll_up "n" eaf-browser-keybinding)
  (eaf-bind-key insert_or_scroll_down "p" eaf-browser-keybinding))

(use-package eaf-image-viewer
  :straight nil
  :after-call find-file-hook)
#+end_src
