#+TITLE: Emacs Configuration
#+AUTHOR: Alex Lu
#+EMAIL: alexluigit@gmail.com
#+PROPERTY: header-args :mkdirp yes
#+OPTIONS: auto-id:t
#+STARTUP: overview

* Overview
:PROPERTIES:
:CUSTOM_ID: Overview-337ea426
:END:
** About
:PROPERTIES:
:CUSTOM_ID: Overview-About-1982a697
:END:

This project is my emacs configuration.

*** Structure
:PROPERTIES:
:CUSTOM_ID: Overview-About-Structure-1d5b46a8
:END:

+ Init file (init.el / early-init.el)
+ Optimization options (early-optimize.el)
+ Core libraries (core/*, core/autoload/*)
+ extensions (lisp/*)
+ Main config file (ale.org)

doc

#+begin_src emacs-lisp :tangle (ale-minimal-config)
;;; minimal.el --- -*- lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp
;;; full.el --- -*- lexical-binding: t -*-
#+end_src

*** COPYING
:PROPERTIES:
:CUSTOM_ID: Overview-About-COPYING-602b4726
:END:

Copyright (c) 2020-2021  Alex Lu <alexluigit@gmail.com>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

** Quickstart
:PROPERTIES:
:CUSTOM_ID: Overview-Quickstart-81baeb33
:END:
*** Dependencies
:PROPERTIES:
:CUSTOM_ID: Overview-Quickstart-Dependencies-d0d7498c
:END:

Here are the dependency list (it might not be a complete list) that this project
required or optionally required.

| Package               | Description                 | Required? |
|-----------------------+-----------------------------+-----------|
| =fd=                    | A modern =find=               |           |
| =rg=                    | A modern =grep=               |           |
| =exa=                   | A modern =ls=                 |           |
| =git=                   | Version control             |           |
| =noto-fonts-emoji=      | Font for emojis             | optional  |
| =words=                 | English words completion    | optional  |
| =victor-mono-nerd-font= | Default fixed pitch font    | optional  |
| =sarasa-gothic= (font)  | Default variable pitch font | optional  |
| =xdotool=               | Automation tool for X11     | optional  |

*** Install
:PROPERTIES:
:CUSTOM_ID: Overview-Quickstart-Install-09df6cce
:END:

This section contails instructions on how to use this config.

- Make sure to backup your own emacs config before installation.

#+begin_src shell :tangle no
cp -r ~/.emacs.d ~/.emacs.d.bak
#+end_src

- Clone the repo and tangle the config.

#+begin_src shell :tangle no
git clone https://www.github.com/alexluigit/emacs-grandview
# either put it to ~/.emacs.d
mv ~/emacs-grandview ~/.emacs.d
# or conform XDG spec
mv ~/emacs-grandview ~/.config/emacs/
# or use symlink
mv ~/emacs-grandview ~/Code/emacs-grandview
ln -sf ~/Code/emacs-grandview ~/.config/emacs

# Tangle the config
emacs --daemon
emacsclient -e '(kill-emacs)'
#+end_src

** Restart script
:PROPERTIES:
:CUSTOM_ID: Overview-Restart_script-3e034509
:END:

Script for starting up emacs.

+ *Why this bash script?*

  Emacs is a single-threaded program, so if it hangs, we can not
  expect it to evaluate any elisp code.

+ *What does this script do?*

  If this org file get modified, =ale-init-build= function will tangle
  this file.  After the build function finishes, it kill current emacs
  and open emacs with new init file.

  Since =ale-init-build= function is added to =kill-emacs-hook=, emacs
  main process only get killed after the tangle function finishes
  (unless we use '-9' flag in kill command).  In my case, it usually
  takes emacs less than 1s to tangle this org file, so if emacs main
  process keep alive for over 3s after *killall emacs* command, it
  probably means emacs get frozen, so we just kill it with *kill -9*.

+ *How to use this script?*

  You don't need to install this script if you have followed
  =Installation= section. This script will be tangled to
  *~/.local/share/em*, so if you want to get access to =em restart= command from
  terminal, make sure *~/.local/bin/em* is in your *PATH*.

Here is the content of the script.

#+begin_src bash :tangle "~/.local/bin/em" :shebang "#!/usr/bin/env bash"
_is_ime_rime () { [[ -d ~/.config/rime ]] || [[ -d ~/.local/share/fcitx5/rime ]]; }

restart () {
  notify-send "Restarting emacs..." 2>/dev/null
  emacs_pid=$(pidof emacs)
  timeout=300
  counter=0
  killall emacs
  while $(kill -0 $emacs_pid 2>/dev/null) && [[ $counter -lt $timeout ]]; do
    counter=$((counter + 1))
    sleep 0.01
  done
  kill -9 $emacs_pid 2>/dev/null
  rm -rf ~/.config/emacs/eln-cache 2>/dev/null
  [[ $1 == "-p" ]] && rm -rf ~/.cache/emacs/{straight/build,eln} 2>/dev/null
  [[ $1 == "-r" ]] && rm -rf ~/.cache/emacs/ale 2>/dev/null
  [[ $1 == "-R" ]] && rm -rf ~/.cache/emacs/{ale,straight,eln} 2>/dev/null
  _is_ime_rime && GTK_IM_MODULE=emacs XMODIFIERS=@im=emacs emacs --daemon || emacs --daemon
  command -v xdotool >/dev/null 2>&1 && xdotool set_desktop 0
  emacsclient -cne '(delete-file "~/nohup.out")' >/dev/null 2>&1
}

open () { emacs -nw ${@}; }

[[ -z "$@" ]] || ! $(declare -f -F $1 >/dev/null 2>&1) && { open ${@:1}; exit 0; }
$1 ${@:2}
#+end_src

You can also restart emacs by invoking =restart-emacs= command inside
emacs (again, comfirm your $PATH environment variable).

#+begin_src emacs-lisp
(defun restart-emacs ()
  "A elisp wrapper to `em' command."
  (interactive)
  (let ((default-directory "~"))
    (start-process "" nil "nohup" "em" "restart")))
#+end_src

* *CORE*
:PROPERTIES:
:CUSTOM_ID: *CORE*-67f1cb7c
:END:

Load core of =emacs-grandview=. It is *NOT* recommended to delete / comment out this section.

** Text editor
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-a71df8cc
:END:
*** Modal editing (meow.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Modal_editing_(meow.el)-b1de82b2
:END:

Unlike =evil-mode=, which tries to create a whole vim emulation in emacs, =meow=
only focus on bringing the goodness of modal editing to vanilla emacs.

You may noticed that I didn't include any keybindings of meow here, that's
because it can be very lengthy and should be configured separately, see
[[#*CORE_CONFIGURATION*-Keybindings-116d13bf][Keybindings]] for details.

If you want to know more about meow or modal editing in general, check out [[https://www.github.com/DoglooksGood/meow][meow]].

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package meow
  :demand t
  :init (meow-global-mode)
  :config
  (advice-add 'meow--maybe-highlight-num-positions :override #'ignore)
  (advice-add 'meow-minibuffer-quit :override #'keyboard-escape-quit)
  (advice-add 'meow-start-kmacro-or-insert-counter :around #'silent!)
  (advice-add 'meow-end-or-call-kmacro :around #'silent!)
  (advice-add 'meow-query-replace :around #'ale-meow-query-replace-auto-fill-advisor)
  (meow--thing-register 'tag #'ale--inner-of-tag #'ale--bounds-of-tag)
  (meow-setup-line-number)
  (setq meow-visit-sanitize-completion nil)
  (setq meow-use-clipboard t)
  (setq meow-esc-delay 0.001)
  (setq meow-keypad-describe-delay 0.5)
  (setq meow-select-on-change t)
  (setq meow-cursor-type-normal 'box)
  (setq meow-cursor-type-insert '(bar . 4))
  (setq meow-cursor-type-default 'hbar)
  (setq meow-selection-command-fallback
        '((meow-replace . meow-yank)
          (meow-reverse . back-to-indentation)
          (meow-change . meow-change-char)
          (ale-meow-save . ale-pulse-save-line)
          (meow-kill . meow-kill-whole-line)
          (meow-pop-selection . ale-files-revert-buffer-no-ask)
          (meow-cancel . keyboard-quit)
          (meow-delete . meow-C-d)))
  (setq meow-char-thing-table
        '((?r . round)
          (?b . square) ;; `b' for bracket
          (?c . curly)
          (?s . string)
          (?e . symbol)
          (?w . window)
          (?B . buffer)
          (?p . paragraph)
          (?\[ . line)
          (?\] . line)
          (?d . defun)
          (?i . indent)
          (?t . tag)
          (?x . extend)))
  (add-to-list 'meow-mode-state-list '(helpful-mode . normal)))
#+end_src

*** Line numbers (display-line-numbers.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Line_numbers_(display-line-numbers.el)-8c919f4f
:END:

Display line numbers when programming.

#+begin_src emacs-lisp
(use-package display-line-numbers
  :straight (:type built-in)
  :hook
  (prog-mode . display-line-numbers-mode))
#+end_src

*** Symbol pairs (embrace.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Symbol_pairs_(embrace.el)-fcd89053
:END:

=embrace.el= is a package for symbol pairs insert/change/delete which resembles
to =surround.vim= in vim.
I've forked this package to extract =embrace-default-pairs= out, so we can use
keys like ~,r~ to select an inner parenthesis block (this assumes your comma key
has been bound to =meow-inner-of-thing=.)

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package embrace
  :straight
  (embrace :type git :depth full :host github
           :repo "cute-jumper/embrace.el"
           :fork (:host github :repo "alexluigit/embrace.el"))
  :after-call meow--selection-type
  :init
  (setq embrace-default-pairs
        '((?r . ("(" . ")"))
          (?R . ("( " . " )"))
          (?c . ("{" . "}"))
          (?C . ("{ " . " }"))
          (?\[ . ("[" . "]"))
          (?\] . ("[ " . " ]"))
          (?a . ("<" . ">"))
          (?A . ("< " . " >"))
          (?s . ("\"" . "\""))
          (?\' . ("\'" . "\'"))
          (?` . ("`" . "`")))))
#+end_src

*** Long line text (so-long.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Long_line_text_(so-long.el)-8cbff31f
:END:

Consistent performance is the reason to enable =global-so-long-mode=, built
into Emacs versions >= 27, which allows the active major mode to gracefully
adapt to buffers with very long lines. What “very long” means is, of course,
configurable: M-x find-library so-long covers several customisation options,
though I find that the defaults require no further intervention from my part.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package so-long
  :after-call find-file-hook
  :straight (:type built-in)
  :config
  (global-so-long-mode))
#+end_src

*** Paragraphs (paragraphs.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Paragraphs_(paragraphs.el)-94234568
:END:

The =ale-fill.el= library is a tiny wrapper around some Emacs settings and modes
that are scrattered around several files, which control (i) how paragraphs or
comments in programming modes should be wrapped to a given column count, and
(ii) what constitutes a sentence. I put them all together here to make things
easier to track.  Use M-n and M-p for navigating between paragraphs.

=ale-fill-fill-mode= sets my desired default column width for all buffers, while
it applies another value for programming modes (in case there is a need to
control the two cases separately). Those values are stored in the variables
=ale-fill-default-column= and =ale-fill-prog-mode-column= respectively. My minor
mode also enables =auto-fill-mode= in text-mode and prog-mode buffers through
the appropriate hooks. Disabling =ale-fill-fill-mode= will remove all those
customisations.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package paragraphs
  :straight (:type built-in)
  :init
  (setq-default truncate-lines t)
  (ale-fill-fill-mode 1)
  :config
  (setq ale-fill-default-column 80)
  (setq ale-fill-prog-mode-column 100)
  (setq sentence-end-double-space t)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t))
#+end_src

*** Jump list (better-jumper.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Jump_list_(better-jumper.el)-890432c5
:END:

Create a jump list (same concept in vim) in emacs.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package better-jumper
  :after-call pre-command-hook
  :config
  (better-jumper-mode +1)
  (ale-jumper-sensible-jump-mode))
#+end_src

*** Quick goto char (avy.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Quick_goto_char_(avy.el)-dda2a3e2
:END:

Jump to any visible text.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package avy
  :config
  (setq avy-timeout-seconds 0.3)
  (setq avy-all-windows nil)
  (setq avy-keys '(?a ?r ?s ?t ?n ?e ?i ?o)))
#+end_src

*** Cross reference (xref.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Cross_reference_(xref.el)-490417b8
:END:

*xref* provides helpful commands for code navigation and discovery.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package xref
  :straight (:type built-in)
  :config
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
  (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'ripgrep))
#+end_src

*** Interactive diff, patch, or merge conflict (ediff.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Text_editor-Interactive_diff,_patch,_or_merge_conflict_(ediff.el)-9c46ac93
:END:

This package provides a convenient way of simultaneous browsing through the
differences between a pair (or a triple) of files or buffers.  The files being
compared, file-A, file-B, and file-C (if applicable) are shown in separate
windows (side by side, one above the another, or in separate frames), and the
differences are highlighted as you step through them.  You can also copy
difference regions from one buffer to another (and recover old differences if
you change your mind).

#+begin_src emacs-lisp
(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< ale-ediff-combine Variant A" A
          ">>>>>>> ale-ediff-combine Variant B" B
          "####### ale-ediff-combine Ancestor" Ancestor
          "======= ale-ediff-combine End"))
  (defun ale/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.
This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*ale-ediff.*" (point-min) (point-max) nil)))
#+end_src

** File management
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-75941d76
:END:
*** Dired (dired.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Dired_(dired.el)-081424ff
:END:

=Dired= is a built-in tool that performs file management operations
inside of an Emacs buffer.  It is simply superb!

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package dired
  :straight (:type built-in)
  :hook
  (dired-mode . (lambda () (interactive) (setq-local mode-line-format nil)))
  :bind
  (:map dired-mode-map
        ("/" . dired-goto-file)
        ("a" . dired-create-empty-file)
        ("f" . ale-dired-toolbox)
        ("r" . ale-dired-jump)
        ("I" . dired-insert-subdir)
        ("?" . dired-create-directory)
        ("O" . dired-find-file-other-window)
        ("i" . ale-dired-file-rename-eol)
        ("d" . dired-kill-subdir)
        ("<" . beginning-of-buffer)
        (">" . end-of-buffer)
        ("[" . dired-prev-dirline)
        ("]" . dired-next-dirline)
        ("o" . dired-up-directory)
        ("^" . mode-line-other-buffer)
        ("x" . dired-do-delete)
        ("y" . dired-do-copy)
        ("." . dired-omit-mode)
        ("% SPC" . ale-dired-rename-space-to-underscore))
  :config
  (setq! ale-dired-tools
         '(("m" "mark file REGEX" dired-mark-files-regexp)
           ("n" "copy file NAME" ale-dired-yank-file-name)
           ("p" "copy file NAME" ale-dired-yank-file-path)
           ("d" "copy file PATH" ale-dired-yank-file-dir)
           ("t" "show file TYPE" dired-show-file-type)
           ("l" "goto file TRUEPATH" ale-dired-file-true-path)))
  (setq dired-kill-when-opening-new-dired-buffer t) ;; added in emacs 28
  (setq dired-clean-confirm-killing-deleted-buffers nil)
  (setq large-file-warning-threshold 50000000)
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-listing-switches "-AGhlv --group-directories-first --time-style=long-iso"))
#+end_src

*** A better dired interface (danger.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-A_better_dired_interface_(danger.el)-3d9f5675
:END:

This package is inspired the popular file manager =ranger=, I created it
on the basis of =ranger.el=. Compare to =ranger.el=, this package only
keeps features I wanted, and some sensible functionalities were added
as well. See details at: https://github.com/alexluigit/danger.el

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package danger
  :after-call pre-command-hook
  :init
  (add-to-list 'load-path (concat straight-base-dir "straight/"
                                  straight-build-dir "/danger/extensions"))
  :straight (danger :type git :depth full :host github :repo "alexluigit/danger.el"
                    :files ("*.el" "extensions"))
  :hook
  (danger-mode . (lambda () (setq cursor-type nil) (setq mode-line-format nil)))
  :bind
  (:map danger-mode-map ("SPC" . danger-show-history))
  :config
  (advice-add 'ale-dired-find-file :override 'danger-find-file-dwim)
  (danger-override-dired-mode)
  (require 'danger-minibuffer)
  (danger-minibuf-preview-mode)
  (setq danger-trash-dir-alist '(("/mnt/HDD/" . ".Trash/files")
                                 ("/mnt/Cloud/" . ".Trash/files"))))
#+end_src

*** Writable dired (wdired.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Writable_dired_(wdired.el)-3a9a82cd
:END:

#+begin_src emacs-lisp
(use-package wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+end_src

*** Find files (files.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Find_files_(files.el)-c8ed4da6
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package files
  :straight (:type built-in)
  :config
  (setq confirm-kill-processes nil)
  (setq permanently-enabled-local-variables '(lexical-binding encoding)))
#+end_src

*** Recent files (recentf.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Recent_files_(recentf.el)-8183094b
:END:

Keep a record of all recently opened files.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package recentf
  :straight (:type built-in)
  :after-call find-file-hook danger
  :config
  (setq recentf-max-saved-items 100)
  (add-to-list 'recentf-exclude (lambda (f) (not (string= (file-truename f) f))))
  (recentf-mode 1))
#+end_src

*** Restore file place (saveplace.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Restore_file_place_(saveplace.el)-d693e126
:END:

Just remember where the point is in any given file.  This can often
be a subtle reminder of what you were doing the last time you
visited that file, allowing you to pick up from there.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package saveplace
  :straight (:type built-in)
  :after-call find-file-hook
  :config
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

*** Auto refresh file content (autorevert.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Auto_refresh_file_content_(autorevert.el)-726d012d
:END:

This mode ensures that the buffer is updated whenever the file
changes.  A change can happen externally or by some other tool
inside of Emacs (e.g. kill a Magit diff).

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package autorevert
  :straight (:type built-in)
  :after-call self-insert-command
  :config
  (setq auto-revert-verbose t)
  (global-auto-revert-mode))
#+end_src

*** Project management (project.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Project_management_(project.el)-2130f546
:END:

#+begin_src emacs-lisp
(use-package project
  :straight (:type built-in)
  :config
  (setq project-switch-commands
        '((project-find-file "File" ?\r)
          (ale-project-find-subdir "Subdir" ?s)
          (project-find-regexp "Grep" ?g)
          (project-dired "Dired" ?d)
          (ale-project-retrieve-tag "Tag switch" ?t)
          (ale-project-magit-status "Magit" ?m)
          (ale-project-commit-log "Log VC" ?l)))
  (setq ale-project-commit-log-limit 25)
  :bind
  (:map project-prefix-map
        ("l" . ale-project-commit-log)
        ("m" . ale-project-magit-status)
        ("s" . ale-project-find-subdir)
        ("t" . ale-project-retrieve-tag)))
#+end_src

*** Trash (trashed.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-File_management-Trash_(trashed.el)-b51c0904
:END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks to =m=
  (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(use-package trashed
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src
** Completion framework
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-69b42cad
:END:

The optimal way of using Emacs is through searching and narrowing
selection candidates.  Spend less time worrying about where things are
on the screen and more on how fast you can bring them into focus.
This is, of course, a matter of realigning priorities, as we still
wish to control every aspect of the interface.

*** Minibuffer and completion functions (minibuffer.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Minibuffer_and_completion_functions_(minibuffer.el)-7aaeb078
:END:

The minibuffer is the epicentre of extended interactivity with all sorts of
Emacs workflows: to select a buffer, open a file, provide an answer to some
prompt, such as a number, regular expression, password, and so on.

What my minibuffer config does:

+ Intangible cursors :: disallow user move cursors into prompt.
+ Recursive minibuffers :: I enable recursive minibuffers.  This
  practically means that you can start something in the minibuffer,
  switch to another window, call the minibuffer again, run some
  commands, and then move back to what you initiated in the original
  minibuffer.  Or simply call an =M-x= command while in the midst of a
  minibuffer session.  To exit, hit =C-[= (=abort-recursive-edit=), though
  the regular =C-g= should also do the trick.

  The =minibuffer-depth-indicate-mode= will show a recursion indicator,
  represented as a number, next to the minibuffer prompt, if a recursive
  edit is in progress.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package minibuffer
  :straight (:type built-in)
  :config
  (setq enable-recursive-minibuffers t)
  (setq minibuffer-eldef-shorten-default t)
  (setq! minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
  (minibuffer-depth-indicate-mode 1))
#+end_src

*** Minibuffer history (savehist.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Minibuffer_history_(savehist.el)-c4fa208a
:END:

Keeps a record of actions involving the minibuffer.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package savehist
  :straight (:type built-in)
  :after-call minibuffer-setup-hook
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (savehist-mode))
#+end_src

*** Vertical completion candidates (vertico.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Vertical_completion_candidates_(vertico.el)-84fd5a77
:END:

Vertico provides a performant and minimalistic vertical completion UI based on
the default completion system. By reusing the built-in facilities, Vertico
achieves full compatibility with built-in Emacs completion commands and
completion tables.

Here I just modified face for current candidate and make height of vertico
window as a constant value.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package vertico
  :after-call pre-command-hook
  :config
  (setq resize-mini-windows 'grow-only)
  (set-face-attribute 'vertico-current nil :background
                      (face-attribute 'lazy-highlight :background nil t)
                      :weight 'semi-bold)
  (vertico-mode 1))
#+end_src

*** Match candidates made easy (orderless.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Match_candidates_made_easy_(orderless.el)-a08036fc
:END:

This package provides an =orderless= completion style that divides the pattern
into components (space-separated by default), and matches candidates that match
all of the components in any order.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package pinyinlib)

(use-package orderless
  :after-call minibuffer-setup-hook
  :config
  (setq completion-styles '(orderless))
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles
        '(ale-orderless-pinyin-only-initialism
          orderless-initialism
          orderless-prefixes
          orderless-regexp))
  (setq orderless-style-dispatchers
        '(ale-orderless-literal-dispatcher
          ale-orderless-initialism-dispatcher
          ale-orderless-without-literal-dispatcher
          ale-orderless-pinyin-dispatcher)))
#+end_src

*** Useful commands using completion (consult.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Useful_commands_using_completion_(consult.el)-bb496c77
:END:

Consult implements a set of =consult-<thing>= commands which use
=completing-read= to select from a list of candidates. Consult provides an
enhanced buffer switcher =consult-buffer= and search and navigation commands
like =consult-imenu= and =consult-line=. Searching through multiple files is
supported by the asynchronous =consult-grep= command. Many Consult commands
allow previewing candidates - if a candidate is selected in the completion view,
the buffer shows the candidate immediately.

The Consult commands are compatible with completion systems based on the Emacs
=completing-read= API, including the default completion system, Icomplete,
Selectrum, Vertico and Embark.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package consult
  :after-call minibuffer-setup-hook
  :init
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq register-preview-delay 0.2)
  (setq register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window)
  (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
  (advice-add #'consult-outline :around #'ale-consult-outline-advisor)
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :bind
  (:map ale-mct-map
        ("/" . consult-line-multi)
        ("e" . consult-compile-error)
        ("r" . consult-ripgrep)
        ("k" . consult-keep-lines)
        ("i" . consult-imenu-multi)
        ("f" . consult-focus-lines)
        ("o" . consult-outline)
        ("R" . consult-register)
        ("y" . consult-yank-from-kill-ring)
        ("m" . consult-minor-mode-menu)
        ("c" . consult-complex-command)
        ("C" . consult-mode-command))
  :config
  (advice-add #'consult-line :around #'ale-consult-line-advisor)
  (setq consult-project-root-function #'ale-consult-project-root)
  (setq consult-line-numbers-widen t)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">"))
#+end_src

*** Keyboard version right-click (embark.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Keyboard_version_right-click_(embark.el)-e1a0f11d
:END:

This package provides a sort of right-click contextual menu for
Emacs, accessed through the `embark-act' command (which you should
bind to a convenient key), offering you relevant actions to use on
a target determined by the context:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package embark
  :after-call dired-after-readin-hook minibuffer-setup-hook
  :bind
  (("C-." . embark-act)
   :map minibuffer-local-map ("C-." . embark-act) ("C-," . embark-become)
   :map embark-collect-mode-map ("C-." . embark-act))
  :config
  (use-package embark-consult :demand t)
  (ale-embark-keymaps 1)
  (setq embark-quit-after-action t)
  (setq embark-action-indicator
        (let ((act (propertize "Act" 'face 'success)))
          (cons act (concat act " on '%s'"))))
  (setq embark-become-indicator (propertize "Become" 'face 'warning)))
#+end_src

*** Candidate annotation (marginalia.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Candidate_annotation_(marginalia.el)-26cd9370
:END:

This is a utility jointly developed by Daniel Mendler and Omar Antolín Camarena
that provides annotations to completion candidates.  It is meant to be
framework-agnostic, so it works with Selectrum, Icomplete, vertico, and Embark.


#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package marginalia
  :after-call minibuffer-setup-hook
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy
          marginalia-annotators-light))
  (marginalia-mode))
#+end_src

*** Auto completion in buffer (company.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Completion_framework-Auto_completion_in_buffer_(company.el)-eba24f5d
:END:

=company= is a modular completion framework.  Modules for retrieving completion
candidates are called backends, modules for displaying them are frontends. It
comes with many backends, e.g. =company-etags=.  These are distributed in
separate files and can be used individually.

=tng= in =company-tng-mode= means tab and go, in this mode tab key will complete and
move to the next candidate meanwhile keep company window open.

#+begin_src emacs-lisp
(use-package company
  :after-call self-insert-command
  :hook
  (text-mode . ale-company-enable-ispell)
  :config
  (global-company-mode)
  (company-tng-mode)
  (setq company-idle-delay 0.0))
#+end_src

** Org mode
:PROPERTIES:
:CUSTOM_ID: *CORE*-Org_mode-5ab4d9d0
:END:
*** Org (org.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Org_mode-Org_(org.el)-570589d1
:END:

In its purest form, Org is a markup language that is similar to Markdown:
symbols are used to denote the meaning of a construct in its context, such as
what may represent a headline element or a phrase that calls for emphasis.

What lends Org its super powers though is everything else built around it: a
rich corpus of Elisp functions that automate, link, combine, enhance, structure,
or otherwise enrich the process of using this rather straightforward system of
plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and workflows
on how to organise one's life with plain text.

This section is all about basic configurations for how does a =.org= file should
look like which can be described briefly as follows:

- use bigger fonts for different levels of heading
- show ellipsis marker when a node is folded.
- center text when make sense
- indent text according to outline structure
- display inline images in url automatically

#+begin_src emacs-lisp
(use-package org
  :straight (:type built-in)
  :hook
  (org-mode . ale-org-font-setup)
  (org-tab-first . org-end-of-line)
  :config
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars t)
  (setq org-startup-folded t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-ellipsis " ▾")
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-image-actual-width nil)
  (setq org-display-remote-inline-images 'download)
  :bind
  (:map org-mode-map
        ([remap org-toggle-comment] . ale-org-comment-entry-in-region)
        ("C-c S-l" . org-toggle-link-display)
        ("C-c C-S-l" . org-insert-last-stored-link)))
#+end_src

*** Source code block (org-src.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Org_mode-Source_code_block_(org-src.el)-780a38a5
:END:

#+begin_src emacs-lisp
(use-package org-src
  :straight (:type built-in)
  :after-call org-mode
  :config
  (push '("conf-unix" . conf-unix) org-src-lang-modes)
  (setq org-edit-src-content-indentation 0)
  (setq org-src-window-setup 'split-window-right))
#+end_src

*** Literate programming (ob.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Org_mode-Literate_programming_(ob.el)-fe3bec67
:END:

Thanks to https://blog.d46.us/advanced-emacs-startup

#+begin_src emacs-lisp
(use-package ob
  :straight (:type built-in)
  :after-call org-cycle
  :hook (org-babel-after-execute . org-redisplay-inline-images)
  :config
  (use-package org-tempo
    :straight (:type built-in)
    :after-call self-insert-command
    :config
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp")))
  (setq org-babel-default-header-args:sh    '((:results . "output replace"))
        org-babel-default-header-args:bash  '((:results . "output replace"))
        org-babel-default-header-args:shell '((:results . "output replace"))))
#+end_src

** User interface
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-7d493ea0
:END:
*** Theme
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Theme-3351ce80
:END:

=modus-vivendi= is a built-in theme in emacs (version >= 28) created by
Protesilaos Stavrou.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(setq modus-themes-links 'no-underline)
(setq modus-themes-mode-line 'borderless)
(add-hook 'emacs-startup-hook (lambda () (load-theme 'modus-vivendi)))
#+end_src

*** Window placement (window.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Window_placement_(window.el)-3072a5af
:END:

The =display-buffer-alist= is intended as a rule-set for controlling
the display of windows.  The objective is to create a more intuitive
workflow where targeted buffer groups or types are always shown in a
given location, on the premise that predictability improves usability.

For each buffer action in it we can define several functions for selecting the
appropriate window.  These are executed in sequence, but my usage thus far
suggests that a simpler method is just as effective for my case.

Additionally, I've set =split-height-threshold= to nil and =split-width-threshold=
to 0 to ensure every new window will open in horizontal split.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package window
  :straight (:type built-in)
  :config
  (setq display-buffer-alist
        `(("\\*\\(Flymake\\|Messages\\|Backtrace\\|Warnings\\|Compile-Log\\|Custom\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.2)
           (side . top))
          ("^\\*\\(Help\\|helpful\\).*"
           (display-buffer-in-side-window)
           (window-width . 0.4)
           (side . right))
          ("\\*\\vc-\\(incoming\\|outgoing\\|Output\\|Register Preview\\).*"
           (display-buffer-at-bottom))))
  (setq help-window-select t)
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (setq split-height-threshold nil)
  (setq split-width-threshold 0))
#+end_src

*** Window focus (ace-window.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Window_focus_(ace-window.el)-8e904e59
:END:

Index based window motions.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package ace-window
  :config
  (setq aw-keys '(?a ?r ?s ?t ?n ?e ?i ?o)))
#+end_src

*** Tab (ale-tab.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Tab_(ale-tab.el)-ae1ba85f
:END:

Tabs for frequently used buffers.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(ale-tab-mode)
#+end_src

*** Modeline (ale-modeline.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Modeline_(ale-modeline.el)-7e8e9935
:END:

=ale-modeline-mode= provides following infos in modeline:
- Meow current state (INSERT/NORMAL...)
- Filename
- Current line / column
- Total lines
- Git branch
Its source code lies in *autoload/modeline.el*

#+begin_src emacs-lisp :tangle (ale-minimal-config)
;; (ale-modeline-mode)
(ale-frame-enable 'ale-modeline-mode)
#+end_src

*** Frame margin (fringe.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Frame_margin_(fringe.el)-0d85a826
:END:

Create a 20 pixel margin for emacs frame.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(add-to-list 'default-frame-alist '(internal-border-width . 20))
(fringe-mode)
#+end_src

*** Pixel scrolling (pixel-scroll.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Pixel_scrolling_(pixel-scroll.el)-9ba3db6b
:END:

Pixelwise scrolling in emacs. This  was added in emacs version > 29, you
need to add =--with-xinput2= in build flags to enable this feature.

#+begin_src emacs-lisp
(when (boundp 'pixel-scroll-precision-mode)
  (pixel-scroll-precision-mode 1))
#+end_src

*** Fonts (fonts.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Fonts_(fonts.el)-5fe477d3
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(ale-frame-enable 'ale-font-setup)

;; https://lists.gnu.org/archive/html/emacs-devel/2021-11/msg01636.html
(defun +modeline-font-temp-fix ()
  (when-let ((default (ale-font-chooser ale-default-fonts)))
    (set-face-attribute 'mode-line nil :font (font-spec :family default :size ale-font-size))
    (set-face-attribute 'mode-line-inactive nil :font (font-spec :family default :size ale-font-size))))
(ale-frame-enable '+modeline-font-temp-fix)
#+end_src

*** Automatic opacity adjustment (opacity.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Automatic_opacity_adjustment_(opacity.el)-4f0d489f
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(ale-frame-enable 'ale-opacity-auto-mode)
#+end_src

*** Pulse line (pulse.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Pulse_line_(pulse.el)-ac78d83b
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(ale-frame-enable 'ale-pulse-line-mode)
#+end_src

*** Transient commands (transient.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-User_interface-Transient_commands_(transient.el)-d8945949
:END:

=transient.el= built-in package in emacs 28 for "transient" commands.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(straight-use-package `(transient ,@(when (>= emacs-major-version 28) '(:type built-in))))

(use-package transient
  :config
  (setq transient-show-popup -0.5)
  (transient-bind-q-to-quit)
  :bind
  ((:map transient-map
         ("<escape>" . transient-quit-all))
   (:map transient-sticky-map
         ("ESC" . transient-quit-all))))
#+end_src

** Utils
:PROPERTIES:
:CUSTOM_ID: *CORE*-Utils-df28d9b5
:END:
*** Git porcelain (magit.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Utils-Git_porcelain_(magit.el)-60a3d018
:END:

#+begin_src emacs-lisp
(use-package magit
  :config
  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-define-global-key-bindings nil)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))
  (setq magit-diff-refine-hunk t)
  (setq magit-repository-directories '(("~/Code" . 1) ("~" . 1)))
  :bind (("C-M-g" . magit-status-here)
         :map magit-diff-section-base-map
         ("<C-return>" . magit-diff-visit-file-other-window)))
#+end_src

*** Vterm (vterm.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Utils-Vterm_(vterm.el)-74c1442a
:END:

#+begin_src emacs-lisp
(use-package vterm
  :config
  (ale-vterm-mux-mode)
  (setq vterm-max-scrollback 5000)
  (set-face-attribute 'vterm-color-white nil :foreground "#cccccc")
  (set-face-attribute 'vterm-color-black nil :foreground "#111111")
  (advice-add 'meow-insert-exit :around #'ale-vterm-escape-advisor)
  (advice-add 'meow-kill-whole-line :around #'ale-vterm-kill-whole-line-advisor)
  :bind
  (("M-v" . ale-vterm-toggle)
   :map vterm-mode-map
   ("M-v" . ale-vterm-toggle)
   ("M-;" . ale-vterm-new)
   ("M-'" . vterm-send-M-apostrophe)
   ("M-\"" . vterm-send-M-quote)
   ("M-/" . vterm-send-M-/)
   ("M-." . ale-vterm-next)
   ("M-," . ale-vterm-prev)
   ("M-RET" . vterm-send-M-return)
   ("s-n" . vterm-next-prompt)
   ("s-p" . vterm-previous-prompt)
   ("S-SPC" . nil)
   ("S-<escape>" . (lambda () (interactive) (meow-normal-mode) (meow--update-cursor)))
   ("<C-i>" . vterm-send-C-i)
   ("C-<delete>" . vterm-send-C-delete)
   ("C-<return>" . vterm-send-F5)))
#+end_src

*** Emacs Manual (info.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Utils-Emacs_Manual_(info.el)-48af98b8
:END:

#+begin_src emacs-lisp
(use-package info
  :straight (:type built-in)
  :bind
  (:map Info-mode-map
        ("n" . next-line)
        ("p" . previous-line)
        ("C-n" . Info-next)
        ("C-p" . Info-prev)
        ("M-n" . forward-paragraph)
        ("M-p" . backward-paragraph)))
#+end_src
*** Helpful (helpful.el)
:PROPERTIES:
:CUSTOM_ID: *CORE*-Utils-Helpful_(helpful.el)-9a1ec3de
:END:

Helpful.el provides a better help buffer. Here are some tweaks I
made for this package and built-in help buffer:

- disable auto jump to other end when cycle through buttons never
- open new window when invoking =helpful-visit-references=.  auto
- focus newly opened help buffer (same behaviour as helpful.el)

#+begin_src emacs-lisp
(use-package helpful
  :hook (helpful-mode . ale-helpful-mode-hook)
  :bind
  (("C-h K" . #'describe-keymap)  ; overrides `Info-goto-emacs-key-command-node'
   ([remap describe-function] . #'helpful-callable)
   ([remap describe-symbol] . #'helpful-symbol)
   ([remap describe-key] . #'helpful-key)
   :map helpful-mode-map
   ("M-n" . (lambda () (interactive) (forward-button 1 nil 1 t)))
   ("M-p" . (lambda () (interactive) (backward-button 1 nil 1 t))))
  :config
  (setq find-function-C-source-directory "~/.cache/paru/clone/emacs-git/src/emacs-git/src"))
#+end_src

** Keybindings
:PROPERTIES:
:CUSTOM_ID: *CORE*-Keybindings-94cb150a
:END:

This section contains all core keybindings of =emacs-grandview=.

*** TOPLVL
:PROPERTIES:
:CUSTOM_ID: *CORE*-Keybindings-TOPLVL-4e855fc2
:END:

For historical reason, terminal can not tell the difference between some key
storkes. For example, =C-i= and =tab=, =C-m= and =Return=, etc. By default, emacs
follow this convention, but it doesn't mean emacs are not able to tell the
difference. To change this behaviour, we can use =input-decode-map= to give =C-i=
different meaning. See =ale-kbd--C-i-fix-GUI= and =ale-kbd--C-i-fix-TERM= for more
details.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(ale-kbd-C-i-fix)
#+end_src

Here are some keybindings that are always available (except in INSERT mode).

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(define-key meow-motion-state-keymap (kbd ale-local-leader-key) meow-leader-keymap)
(define-key meow-motion-state-keymap
            (kbd (concat ale-local-leader-key " " ale-local-leader-key)) 'ale-meow-leader-space)

(meow-motion-overwrite-define-key
 '("/" . consult-line)
 '("<escape>" . ale-meow-escape))
#+end_src

*** INSERT
:PROPERTIES:
:CUSTOM_ID: *CORE*-Keybindings-INSERT-e72706e7
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(bind-keys
 :map meow-insert-state-keymap
 ("C-u" . meow-kill-whole-line)
 ("<C-i>" . meow-right)
 ("C-o" . meow-left))
#+end_src

*** NORMAL
:PROPERTIES:
:CUSTOM_ID: *CORE*-Keybindings-NORMAL-199d0f3b
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(meow-normal-define-key
 '("0" . meow-digit-argument)
 '("1" . meow-digit-argument)
 '("2" . meow-digit-argument)
 '("3" . meow-digit-argument)
 '("4" . meow-digit-argument)
 '("5" . meow-digit-argument)
 '("6" . meow-digit-argument)
 '("7" . meow-digit-argument)
 '("8" . meow-digit-argument)
 '("9" . meow-digit-argument)
 '("<escape>" . ale-meow-escape)
 '("/" . consult-line)
 '("%" . ale-match-paren)
 '(";" . meow-reverse)
 '("," . meow-inner-of-thing)
 '("." . meow-bounds-of-thing)
 '("<" . beginning-of-buffer)
 '(">" . end-of-buffer)
 '("[" . meow-beginning-of-thing)
 '("]" . meow-end-of-thing)
 '("-" . negative-argument)
 '("=" . meow-query-replace)
 '("+" . meow-query-replace-regexp)
 '("\\" . meow-pop-selection)
 '("|" . meow-pop-all-selection)
 '("^" . meow-last-buffer)
 '("a" . ale-meow-insert)
 '("A" . ale-meow-insert-at-first-non-whitespace)
 '("b" . meow-back-word)
 '("B" . meow-back-symbol)
 '("c" . meow-change)
 '("C" . meow-change-save)
 '("d" . meow-delete)
 '("e" . meow-line)
 '("E" . ale-inner-line)
 '("f" . meow-next-word)
 '("F" . meow-next-symbol)
 '("g" . meow-grab)
 '("G" . meow-pop-grab)
 '("h" . embrace-commander)
 '("i" . meow-right)
 '("I" . meow-right-expand)
 '("j" . ale-top-join-line)
 '("J" . meow-join)
 '("k" . meow-kill)
 '("K" . meow-kmacro-matches)
 '("l" . meow-kmacro-lines)
 '("m" . meow-mark-word)
 '("M" . meow-mark-symbol)
 '("n" . meow-next)
 '("N" . meow-open-below)
 '("o" . meow-left)
 '("O" . meow-left-expand)
 '("p" . meow-prev)
 '("P" . meow-open-above)
 '("q" . ale-quit)
 '("r" . meow-search)
 '("s" . meow-sync-grab)
 '("S" . meow-swap-grab)
 '("t" . avy-goto-char-timer)
 '("T" . avy-resume)
 '("u" . undo)
 '("U" . undo-redo)
 '("v" . meow-visit)
 '("w" . meow-block)
 '("W" . meow-block-expand)
 '("x" . ale-meow-save)
 '("y" . meow-replace)
 '("Y" . meow-yank-pop)
 '("z" . meow-start-kmacro-or-insert-counter)
 '("Z" . meow-end-or-call-kmacro))
#+end_src

*** LEADER
:PROPERTIES:
:CUSTOM_ID: *CORE*-Keybindings-LEADER-dd15d509
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(meow-leader-define-key
 '("0" . delete-window)
 '("1" . delete-other-windows)
 '("2" . ale-split-window-below)
 '("3" . ale-split-window-right)
 '("4" . ctl-x-4-prefix)
 '("5" . ctl-x-5-prefix)
 '("8" . insert-char)
 '("9" . tab-map)
 '("SPC" . ale-meow-leader-space)
 '("?" . describe-keymap)
 '("/" . describe-symbol)
 '(";" . ale-comment-or-uncomment-region)
 '("a" . ale-apps-map)
 '("e" . dired-jump)
 '("f" . ale-files-map)
 '("E" . eval-expression)
 '("i" . list-buffers)
 '("k" . kill-this-buffer)
 '("n" . ale-project-find-file)
 '("o" . ale-org-map)
 '("p" . project-map)
 '("r" . register-map)
 '("t" . ale-mct-map)
 '("w" . save-buffer)
 '("z" . window-toggle-side-windows))
#+end_src

*** GLOBAL
:PROPERTIES:
:CUSTOM_ID: *CORE*-Keybindings-GLOBAL-9b1ddcfc
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(bind-keys
 :map global-map
 ("C-;" . exchange-point-and-mark)
 ("<C-i>" . better-jumper-jump-forward)
 ("C-o" . better-jumper-jump-backward)
 ("M-n" . ale-tab-next)
 ("M-p" . ale-tab-previous)
 ("M-o" . ace-select-window)
 ("M-SPC" . ale-monocle-mode) ; replaced `just-one-space'
 ("C-c C-M-m" . ale-show-messages)
 :map minibuffer-local-map
 ("S-<return>" . ale-files-other-window)
 ("C-u" . meow-kill-whole-line)
 ("<C-i>" . forward-char)
 ("C-o" . backward-char)
 :map ale-files-map
 ("." . ale-files-dotfiles)
 ("a" . ale-files-browse-all-directories)
 ("e" . ale-files-edit-emacs-config)
 ("l" . find-library)
 ("n" . danger)
 ("r" . ale-files-rename-file-and-buffer)
 ("u" . ale-files-in-user-dirs)
 :map ale-apps-map
 ("o" . ale-opacity-set)
 ("=" . count-words))
#+end_src

* Extras
:PROPERTIES:
:CUSTOM_ID: Extras-ee4a17aa
:END:
** Text editor
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-8f02d31d
:END:
*** Input method (rime.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Input_method_(rime.el)-918c383f
:END:
**** Autoload
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Input_method_(rime.el)-Autoload-004c7e4b
:END:

#+begin_src emacs-lisp
;;; ale-rime.el --- -*- lexical-binding: t -*-

;;;###autoload
(defun ale/rime-return-advice (fn &rest args)
  "Make return key (commit script text) compatible with vterm."
  (interactive)
  (if (eq major-mode 'vterm-mode)
      (progn
        (let ((input (rime-lib-get-input)))
          (execute-kbd-macro (kbd "<escape>"))
          (toggle-input-method)
          (dotimes (i (length input))
            (execute-kbd-macro (kbd (substring input i (+ i 1)))))
          (toggle-input-method)))
    (apply fn args)))

;;;###autoload
(defun ale/rime--candidate-num-format (num select-labels)
  "Format for the number before each candidate."
  (if select-labels
      (format "%s " (nth (1- num) select-labels))
    (format "%d. " num)))
#+end_src

**** Config
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Input_method_(rime.el)-Config-9e6817af
:END:

#+begin_src emacs-lisp
(use-package rime
  :after-call self-insert-command
  :bind
  (("S-SPC" . toggle-input-method)
   :map rime-active-mode-map
   ("C-`" . rime-send-keybinding)
   ("C-k" . rime-send-keybinding)
   ("<C-i>" . rime-send-keybinding)
   ("C-o" . rime-send-keybinding)
   ("C-a" . rime-send-keybinding)
   ("C-e" . rime-send-keybinding)
   ("<escape>" . (lambda () (interactive) (execute-kbd-macro (kbd "C-g"))))
   ([tab] . rime-send-keybinding))
  :config
  (setq default-input-method "rime")
  (setq rime-disable-predicates '(meow-normal-mode-p
                                  meow-motion-mode-p
                                  meow-keypad-mode-p
                                  rime-predicate-after-alphabet-char-p))
  (setq rime-inline-predicates '(rime-predicate-space-after-cc-p
                                 rime-predicate-current-uppercase-letter-p))
  (set-face-attribute 'rime-preedit-face nil
                      :foreground "#80c0e0" :background "#404040"
                      :inverse-video nil :weight 'bold)
  (setq rime-show-candidate 'posframe)
  (setq rime-posframe-style 'vertical)
  (setq rime-posframe-properties
        (list :font "Sarasa Mono SC"
              :internal-border-width 10))
  (setq rime-title " ㄓ")
  (setq rime-candidate-num-format-function 'ale/rime--candidate-num-format)
  (advice-add 'rime--return :around 'ale/rime-return-advice))
#+end_src

*** Snippet (yasnippet.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Snippet_(yasnippet.el)-f2798e00
:END:

#+begin_src emacs-lisp
(use-package yasnippet
  :after-call self-insert-command
  :config
  (setq! yas-snippet-dirs `(,(expand-file-name "snippets" INIT-DIR)))
  (yas-global-mode))
#+end_src

*** Pair insertion (eletric.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Pair_insertion_(eletric.el)-eee2e40d
:END:

Emacs labels as `electric' any behaviour that involves contextual auto-insertion
of characters.

- Indent automatically.

- If =electric-pair-mode= is enabled (which I might do manually),
  insert quotes and brackets in pairs.  Only do so if there is no
  alphabetic character after the cursor.

- To get those numbers, evaluate =(string-to-char CHAR)= where CHAR
  is the one you are interested in.  For example, get the literal
  tab's character with `(string-to-char "\t")'.

- While inputting a pair, inserting the closing character will just
  skip over the existing one, rather than add a new one.

- Do not skip over whitespace when operating on pairs.  Combined
  with the above point, this means that a new character will be
  inserted, rather than be skipped over.  I find this better,
  because it prevents the point from jumping forward, plus it
  allows for more natural editing.

- The rest concern the conditions for transforming quotes into
  their curly equivalents.  I keep this disabled, because curly
  quotes are distinct characters.  It is difficult to search for
  them.  Just note that on GNU/Linux you can type them directly by
  hitting the "compose" key and then an angled bracket (=<= or =>=)
  followed by a quote mark.

#+begin_src emacs-lisp
(use-package electric
  :config
  (advice-add 'electric-pair-post-self-insert-function :around
              (lambda (fn &rest args) (let ((mark-active nil)) (apply fn args))))
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (electric-quote-mode -1)
  :hook
  (org-mode . ale-electric-inhibit-<)
  (minibuffer-setup . (lambda () (unless (eq this-command 'eval-expression) (electric-pair-mode 0))))
  (minibuffer-exit . (lambda () (electric-pair-mode 1))))
#+end_src

*** Parentheses (paren.el / rainbow-delimiters.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Parentheses_(paren.el__rainbow-delimiters.el)-25d97916
:END:

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.
- Use rainbow color for delimiters

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package paren
  :straight (:type built-in)
  :after-call meow-block meow-line self-insert-command
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (show-paren-mode))

(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Prettify symbols (prog-mode.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Text_editor-Prettify_symbols_(prog-mode.el)-01d7befb
:END:

#+begin_src emacs-lisp
(use-package prog-mode
  :straight nil
  :hook (prog-mode . prettify-symbols-mode)
  :config
  (setq-default prettify-symbols-alist
                '(("lambda" . ?λ)
                  ("<-" . ?←)
                  ("->" . ?→)
                  ("->>" . ?↠)
                  ("=>" . ?⇒)
                  ("/=" . ?≠)
                  ("!=" . ?≠)
                  ("==" . ?≡)
                  ("<=" . ?≤)
                  (">=" . ?≥)
                  ("=<<" . (?= (Br . Bl) ?≪))
                  (">>=" . (?≫ (Br . Bl) ?=))
                  ("<=<" . ?↢)
                  (">=>" . ?↣)))
  (setq prettify-symbols-unprettify-at-point 'right-edge))
#+end_src

** Org mode
:PROPERTIES:
:CUSTOM_ID: Extras-Org_mode-acdf7707
:END:
*** Bullet (org-superstar.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Org_mode-Bullet_(org-superstar.el)-ee1ddf29
:END:

#+begin_src emacs-lisp
(use-package org-superstar
  :config
  (setq org-superstar-item-bullet-alist '((?* . ?•) (?+ . ?+) (?- . ?•)))
  (setq org-superstar-remove-leading-stars t)
  (setq org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●"))
  :hook
  (org-mode . org-superstar-mode))
#+end_src

*** Reveal invisible org elements (org-appear.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Org_mode-Reveal_invisible_org_elements_(org-appear.el)-5a519b8e
:END:

#+begin_src emacs-lisp
(use-package org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-hide-emphasis-markers t))
#+end_src

*** Habit (org-habit.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Org_mode-Habit_(org-habit.el)-84378bbd
:END:

#+begin_src emacs-lisp
(use-package org-habit
  :straight (:type built-in)
  :config
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60))
#+end_src

*** Wiki (org-roam.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Org_mode-Wiki_(org-roam.el)-21a1dff1
:END:

#+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-id-link-to-org-use-id t)
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory (file-truename "~/Documents/roam"))
  (org-roam-completion-everywhere t)
  :bind
  (:map ale-org-map
        ("l" . org-roam-buffer-toggle)
        ("f" . org-roam-node-find)
        ("g" . org-roam-graph)
        ("i" . org-roam-node-insert)
        ("c" . org-roam-capture)
        ("j" . org-roam-dailies-capture-today))
  :config
  (org-roam-setup))
#+end_src

#+RESULTS:
: org-roam-dailies-capture-today

*** Slide (org-tree-slide.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Org_mode-Slide_(org-tree-slide.el)-93a2298d
:END:

=org-tree-slide.el= is a presentation tool using =org-mode=.

#+begin_src emacs-lisp
(use-package org-tree-slide)
#+end_src

** User interface
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-7ec18361
:END:
*** Icons (all-the-icons.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Icons_(all-the-icons.el)-11f3bcb6
:END:

This package is a utility for using and formatting various Icon fonts within
Emacs.  Icon Fonts allow you to propertize and format icons the same way you
would normal text.  This enables things such as better scaling of and anti
aliasing of the icons.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package all-the-icons
  :init
  (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
    (all-the-icons-install-fonts)))
#+end_src

*** A colorful dired (diredfl.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-A_colorful_dired_(diredfl.el)-96954331
:END:

Additional syntax highlighting in dired buffer.

#+begin_src emacs-lisp
(use-package diredfl
  :hook (dired-mode . diredfl-mode))
#+end_src

*** Interactive query replace (anzu.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Interactive_query_replace_(anzu.el)-49a57e17
:END:

=anzu.el= provides a minor mode which displays 'current match/total
matches' in the mode-line in various search modes.  This makes it
easy to understand how many matches there are in the current buffer
for your search query.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package anzu
  :after-call isearch-mode
  :bind
  ([remap query-replace] . anzu-query-replace)
  ([remap query-replace-regexp] . anzu-query-replace-regexp)
  :config
  (global-anzu-mode +1))
#+end_src

*** Alternative isearch UI (isearch-mb.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Alternative_isearch_UI_(isearch-mb.el)-4d292b47
:END:

This package provides an alternative isearch UI based on the minibuffer.  This
allows editing the search string in arbitrary ways without any special maneuver;
unlike standard isearch, cursor motion commands do not end the search.
Moreover, the search status information in the echo area and some keybindings
are slightly simplified.

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package isearch-mb
  :after-call isearch-mode
  :config
  (isearch-mb-mode)
  (add-to-list 'isearch-mb--with-buffer #'consult-isearch-history)
  (add-to-list 'isearch-mb--after-exit #'anzu-isearch-query-replace)
  :bind
  (:map isearch-mb-minibuffer-map
        ([remap previous-matching-history-element] . consult-isearch-history)))
#+end_src

*** Window position (transpose-frame.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Window_position_(transpose-frame.el)-75b05cdf
:END:

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
(use-package transpose-frame)
#+end_src

*** Fill column (visual-fill-column.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Fill_column_(visual-fill-column.el)-765e3035
:END:

#+begin_src emacs-lisp
(use-package visual-fill-column)
#+end_src

*** Key bindings hint (which-key.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Key_bindings_hint_(which-key.el)-f9058599
:END:

#+begin_src emacs-lisp
(use-package which-key
  :init
  (which-key-mode 1 ))
#+end_src

*** Buffer list (ibuffer.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Buffer_list_(ibuffer.el)-ea7d7e3b
:END:

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.

#+begin_src emacs-lisp
(use-package ibuffer
  :init
  (advice-add 'list-buffers :override 'ibuffer)
  :bind
  (:map ibuffer-mode-map
        ("M-o" . nil)
        ("* f" . ibuffer-mark-by-file-name-regexp)
        ("* g" . ibuffer-mark-by-content-regexp)
        ("* n" . ibuffer-mark-by-name-regexp)
        ("s n" . ibuffer-do-sort-by-alphabetic)
        ("/ g" . ibuffer-filter-by-content))
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-never-show-predicates '("^ \\*.*"))
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " " (name 16 -1) " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook (lambda () (interactive) (hl-line-mode) (ibuffer-update 0))))
#+end_src
*** Hunk indicator (git-gutter.el)
:PROPERTIES:
:CUSTOM_ID: Extras-User_interface-Hunk_indicator_(git-gutter.el)-6206a06d
:END:

#+begin_src emacs-lisp
(use-package git-gutter
  :config
  (custom-set-variables
   '(git-gutter:modified-sign "⏽")
   '(git-gutter:added-sign "⏽")
   '(git-gutter:deleted-sign "⏽")))
#+end_src

** Utils
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-235edba8
:END:
*** Man page (man.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Man_page_(man.el)-279510ed
:END:

#+begin_src emacs-lisp
(use-package man
  :straight (:type built-in)
  :bind
  (:map Man-mode-map
        ("q" . kill-this-buffer))
  :config
  (setq Man-notify-method 'newframe))
#+end_src
*** Ripgrep (rg.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Ripgrep_(rg.el)-d92e6c2b
:END:
**** Autoload
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Ripgrep_(rg.el)-Autoload-fdfcca61
:END:

The purpose of the function =ale/rg-define-toggle= is to avoid executing
=rg-define-toggle= directly in =use-package=, because this macro introduces too many
deps that we don't need at startup.

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-rg.el -*- lexical-binding: t; -*-

;;;###autoload
(defun ale/rg-define-toggles ()
  "Define toggles in `rg-mode'."
  (rg-define-toggle "--context 3" (kbd "C"))
  (rg-define-toggle "-A 5" (kbd "A")))

(provide 'ale-rg)
#+end_src

**** Config
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Ripgrep_(rg.el)-Config-a16f247e
:END:

#+begin_src emacs-lisp
(use-package rg
  :config
  (ale/rg-define-toggles)
  :bind
  (:map ale-mct-map
        ("g" . rg)))
#+end_src

*** Writable grep (wgrep.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Writable_grep_(wgrep.el)-3143bf57
:END:

With =wgrep= we can directly edit the results of a grep and save the changes to
all affected buffers.  In principle, this is the same as what the built-in occur
offers.  We can use it to operate on a list of matches by leveraging the full
power of Emacs' editing capabilities (e.g. keyboard macros, query and replace a
regexp .etc).

#+begin_src emacs-lisp
(use-package wgrep
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  :bind
  (:map wgrep-mode-map
        ("M-n" . next-error-no-select)
        ("M-p" . previous-error-no-select)))
#+end_src

*** Pdf reader (pdf-tools.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Pdf_reader_(pdf-tools.el)-2ac4cc7a
:END:

#+begin_src emacs-lisp
(use-package pdf-tools
  :after-call dired-after-readin-hook minibuffer-setup-hook
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t)
  ;; turn off cua so copy works
  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
  ;; more fine-grained zooming
  (setq pdf-view-resize-factor 1.1)
  ;; keyboard shortcuts
  :bind
  (:map pdf-view-mode-map
  ("C-s" . isearch-forward)
  ("h" . pdf-annot-add-highlight-markup-annotation)
  ("t" . 'pdf-annot-add-text-annotation)
  ("D" . 'pdf-annot-delete)))
#+end_src

*** Epub reader (nov.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Epub_reader_(nov.el)-ab651de6
:END:

#+begin_src emacs-lisp
(use-package shrface
  :after nov
  :config
  (shrface-basic)
  (shrface-trial)
  (add-to-list 'shr-external-rendering-functions
               '(span . shrface-tag-span))
  (shrface-default-keybindings) ; setup default keybindings
  (setq shrface-href-versatile t))

(use-package nov
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (add-hook 'nov-mode-hook 'ale/nov-setup)
  :config
  (advice-add 'nov-render-title :override #'ignore)
  (setq nov-shr-rendering-functions '((img . nov-render-img)
                                      (title . nov-render-title)
                                      (b . shr-tag-b)))
  (setq nov-shr-rendering-functions
        (append nov-shr-rendering-functions
                shr-external-rendering-functions))
  (defun ale/nov-setup ()
    (require 'shrface)
    (shrface-mode)))
#+end_src

*** Murl (ale-murl.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Murl_(ale-murl.el)-9a852f2d
:END:
**** Autoload
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Murl_(ale-murl.el)-Autoload-2bb85cf4
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-murl.el -*- lexical-binding: t; -*-

(require 'json)

(defvar ale/murl-list-file (expand-file-name "~/.cache/murl/main_list.json"))

(defun ale/murl--playlist ()
  (append (json-read-file ale/murl-list-file) nil))

(defun ale/murl--get-attr (title attr)
  (cl-dolist (i (ale/murl--playlist))
    (when (string= title (cdr (assq 'title i)))
      (cl-return (cdr (assq attr i))))))

;;;###autoload
(defun ale/murl-open (&optional no-hist)
  "Select video or stream to play in mpv."
  (interactive "P")
  (unless no-hist
    (let* ((clip (condition-case nil (current-kill 0 t) (error ""))))
      (set-text-properties 0 (length clip) nil clip)
      (when-let* ((is-url (string-prefix-p "http" clip))
                  (json (shell-command-to-string (concat "murl -P 1088 json '" clip "'")))
                  (valid (string-prefix-p "{" json))
                  (obj (json-read-from-string json))
                  (playlist (ale/murl--playlist)))
        (cl-pushnew obj playlist :test 'equal)
        (with-temp-buffer
          (insert (json-encode (vconcat playlist)))
          (json-pretty-print-buffer)
          (write-region (point-min) (point-max) ale/murl-list-file)))))
  (let* ((cands-raw (mapcar (lambda (i) (cdr (assq 'title i))) (ale/murl--playlist)))
         (annotation (lambda (s) (marginalia--documentation (ale/murl--get-attr s 'url))))
         (cands (ale-minibuffer-append-metadata annotation cands-raw))
         (title (completing-read "murls: " cands))
         (sub (ale/murl--get-attr title 'sub)))
    (call-process "murl" nil 0 nil "-r" "-f" "-P" "1088" "-s" sub (ale/murl--get-attr title 'url))))

(provide 'ale-murl)
#+end_src

**** Config
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Murl_(ale-murl.el)-Config-d34e795b
:END:

#+begin_src emacs-lisp
(bind-keys
 :map ale-apps-map
 ("m" . ale/murl-open))
#+end_src

*** Dictionary (fanyi.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Dictionary_(fanyi.el)-ebcda713
:END:

#+begin_src emacs-lisp
(use-package fanyi
  :bind
  (:map ale-apps-map
        ("t" . fanyi-dwim))
  :custom
  (fanyi-providers '(fanyi-etymon-provider
                     fanyi-longman-provider)))
#+end_src

*** Forges (forge.el)
:PROPERTIES:
:CUSTOM_ID: Extras-Utils-Forges_(forge.el)-95e0681b
:END:

#+begin_src emacs-lisp
(use-package forge)
#+end_src

* Programming
:PROPERTIES:
:CUSTOM_ID: Programming-ced42c83
:END:
** Languages
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-20e54288
:END:
*** .rs
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.rs-d4906770
:END:

#+begin_src emacs-lisp
(use-package rust-mode
  :hook
  (rust-mode . (lambda () (setq indent-tabs-mode nil))))
#+end_src

*** .c|cpp
:PROPERTIES:
:CUSTOM_ID: Programming-Languages__Filetypes-.ccpp-af24247b
:END:

#+begin_src emacs-lisp
(use-package ob-C
  :straight (:type built-in)
  :after-call org-cycle
  :commands (org-babel-execute:C
             org-babel-expand:C
             org-babel-execute:cpp
             org-babel-expand:cpp)
  :config
  (add-to-list 'org-structure-template-alist '("cc" . "src C"))
  (add-to-list 'org-structure-template-alist '("cp" . "src cpp")))
#+end_src

*** .py
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.py-6c13a4b1
:END:

#+begin_src emacs-lisp
(use-package python
  :straight (:type built-in)
  :config
  (setq python-indent-offset 4))
#+end_src

#+begin_src emacs-lisp
(use-package ob-python
  :straight (:type built-in)
  :after-call org-cycle
  :commands (org-babel-execute:python)
  :config
  (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src

*** .lua
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.lua-fa0cf5f5
:END:

#+begin_src emacs-lisp
(use-package lua-mode
  :config
  (setq lua-indent-level 2))
#+end_src

*** .yaml
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.yaml-28a51e72
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package yaml-mode)
#+end_src

*** .js|.jsx
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.jsx?-5b9bedbd
:END:

#+begin_src emacs-lisp
(use-package js
  :straight (:type built-in)
  :config
  (setq js-indent-level 2))

(use-package web-mode
  :config
  (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
  :hook
  (web-mode . (lambda ()
                (emmet-mode)
                (setq web-mode-markup-indent-offset 2)
                (setq web-mode-code-indent-offset 2)
                (setq web-mode-script-padding 0)))
  :mode (("\\.vue\\'" . web-mode)
         ("\\.jsx?$" . web-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package ob-js
  :straight (:type built-in)
  :after-call org-cycle
  :commands (org-babel-execute:js)
  :config
  (add-to-list 'org-structure-template-alist '("js" . "src js")))
#+end_src

*** .sh|.zsh
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.z?sh-b993a3a1
:END:

#+begin_src emacs-lisp :tangle (ale-minimal-config)
(use-package sh-script
  :straight (:type built-in)
  :config
  (setq sh-basic-offset 2))
#+end_src

#+begin_src emacs-lisp
(use-package ob-shell
  :straight (:type built-in)
  :after-call org-cycle
  :commands (org-babel-execute:bash)
  :config
  (add-to-list 'org-structure-template-alist '("sh" . "src bash")))
#+end_src

*** .html
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.html-4f4121f0
:END:

#+begin_src emacs-lisp
(use-package emmet-mode)
#+end_src

*** .tex
:PROPERTIES:
:CUSTOM_ID: Programming-Languages-.tex-75bc10f3
:END:

#+begin_src emacs-lisp
(use-package ob-latex
  :straight (:type built-in)
  :after-call org-cycle
  :commands (org-babel-execute:latex org-babel-expand:latex)
  :config
  (add-to-list 'org-structure-template-alist '("la" . "src latex")))
#+end_src

*** Makefile
:PROPERTIES:
:CUSTOM_ID: Programming-Languages__Filetypes-Makefile-75791d96
:END:

#+begin_src emacs-lisp
(use-package ob-makefile
  :straight (:type built-in)
  :after-call org-cycle
  :commands (org-babel-execute:makefile)
  :config
  (add-to-list 'org-structure-template-alist '("mk" . "src makefile")))
#+end_src

** DevTools
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-906375ad
:END:
*** LSP (lsp.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-LSP_(lsp.el)-4c71009f
:END:
**** Autoload
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-LSP_(lsp.el)-Autoload-beb6900d
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-lsp.el --- -*- lexical-binding: t -*-

(defun ale/lsp-pyright-import-venv ()
  "Fix `import' resolution with projects with virtual env like conda."
  (require 'lsp-pyright)
  (let* ((pr-root (lsp-workspace-root))
         (py-ver "python3.9")
         (extra-path (concat pr-root "/envs/lib/" py-ver "/site-packages")))
    (setq lsp-pyright-extra-paths (vector extra-path))))

(defun ale/lsp--inhibit ()
  "Disable `lsp-deferred' in minibuffer."
  (advice-add 'lsp-deferred :override #'ignore))

(defun ale/lsp--recover ()
  "Recover `lsp-deferred' after quit minibuffer."
  (advice-remove 'lsp-deferred #'ignore))

;;;###autoload
(define-minor-mode ale/lsp-mode
  "Inhibit lsp in minibuffer."
  :init-value nil
  :global t
  (if ale/lsp-mode
      (progn
        (add-hook 'minibuffer-setup-hook 'ale/lsp--inhibit)
        (add-hook 'minibuffer-exit-hook 'ale/lsp--recover))
    (progn
      (remove-hook 'minibuffer-setup-hook 'ale/lsp--inhibit)
      (remove-hook 'minibuffer-exit-hook 'ale/lsp--recover))))

(provide 'ale-lsp)
#+end_src

**** Config
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-LSP_(lsp.el)-Config-c060d3d2
:END:

#+begin_src emacs-lisp
(use-package lsp-mode
  :hook ((sh-mode
          lua-mode
          python-mode
          web-mode
          typescript-mode
          rust-mode)
         . lsp-deferred)
  :init
  (ale/lsp-mode)
  :config
  (setq lsp-eldoc-hook nil)
  (setq lsp-signature-auto-activate t)
  (setq lsp-signature-function 'lsp-signature-posframe)
  (setq lsp-signature-doc-lines 20)
  (setq lsp-server-install-dir (expand-file-name (concat user-emacs-directory "lsp")))
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\envs\\'")
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols)))
#+end_src

**** Extensions
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-LSP_(lsp.el)-Extensions-87cd1753
:END:

#+begin_src emacs-lisp
(use-package lsp-tailwindcss
  :after (lsp-mode web-mode)
  :init
  (setq lsp-tailwindcss-add-on-mode t))

(use-package lsp-pyright
  :hook (python-mode . ale/lsp-pyright-import-venv)
  :init
  (when (executable-find "python3")
    (setq lsp-pyright-python-executable-cmd "python3")))

(use-package lsp-ui
  :after-call lsp-deferred
  :config
  (setq lsp-ui-sideline-show-code-actions nil)
  (setq lsp-ui-doc-position 'bottom)
  :hook
  (lsp-mode . lsp-ui-mode))
#+end_src

*** Virturl environment (conda.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Virturl_environment_(conda.el)-2738a5db
:END:
**** Autoload
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Virturl_environment_(conda.el)-Autoload-45fc1daf
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-conda.el --- -*- lexical-binding: t -*-

;;;###autoload
(defun ale-conda-env-activate-for-buffer-ad ()
  "Advice for `conda-env-activate-for-buffer'.

Make it support local `conda-env-subdirectory' such as `./envs'."
  (interactive)
  (if-let ((dir-local-env (bound-and-true-p conda-project-env-path)))
      (conda-env-activate dir-local-env)
    (when-let* ((filename (buffer-file-name))
                (yml-file (conda--find-env-yml (f-dirname filename)))
                (yml-path (f-dirname yml-file))
                (prefix-env (concat yml-path "/" conda-env-subdirectory "/")))
      (if (file-exists-p prefix-env)
          (unless (string= prefix-env (or conda-env-current-name ""))
            (conda-env-activate-path prefix-env))
        (when-let ((env-name (conda-env-name-to-dir
                              (conda--get-name-from-env-yml yml-file))))
          (unless (string= env-name (or conda-env-current-name ""))
            (conda-env-activate env-name)))))))

;;;###autoload
(define-minor-mode +conda-env-autoactivate-mode
  "Toggle +conda-env-autoactivate mode.

This mode automatically tries to activate a conda environment for the current
buffer."
  :group 'conda
  :global t
  (if +conda-env-autoactivate-mode
      (progn
        (advice-add 'pop-to-buffer :after #'conda--switch-buffer-auto-activate)
        (advice-add 'switch-to-buffer :after #'conda--switch-buffer-auto-activate))
    (advice-remove 'pop-to-buffer #'conda--switch-buffer-auto-activate)
    (advice-remove 'switch-to-buffer #'conda--switch-buffer-auto-activate)))
#+end_src

**** Config
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Virturl_environment_(conda.el)-Config-f92c947d
:END:

#+begin_src emacs-lisp
(use-package conda
  :after-call find-file-hook
  :config
  (setq conda-anaconda-home "/opt/miniconda/")
  (setq conda-env-home-directory "/opt/miniconda/")
  (setq conda-message-on-environment-switch t)
  (advice-add 'conda-env-activate-for-buffer
              :override #'ale-conda-env-activate-for-buffer-ad)
  (+conda-env-autoactivate-mode t)
  :hook
  (conda-postactivate . (lambda () (interactive) (jupyter-available-kernelspecs t))))
#+end_src

*** Jupyter (jupyter.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Jupyter_(jupyter.el)-27ba08f2
:END:

#+begin_src emacs-lisp
(use-package jupyter
  :after-call (org-cycle conda-preactivate-hook)
  :config
  ;; FIXME: jupyter require this function but it doesn't exist in emacs-version > 28.
  (defun ansi-color--find-face (codes)
    "Return the face corresponding to CODES."
    (let (faces)
      (while codes
        (let ((face (ansi-color-get-face-1 (pop codes))))
	        (unless (eq face 'default)
	          (push face faces))))
      (if (cdr faces) (nreverse faces) (car faces))))
  (require 'ob-jupyter)
  (org-babel-jupyter-override-src-block "python")
  (setq org-babel-default-header-args:python '((:async . "yes") (:kernel . "python3"))))
#+end_src

*** Colorizer (rainbow-mode.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Colorizer_(rainbow-mode.el)-9b193930
:END:

#+begin_src emacs-lisp
(use-package rainbow-mode
  :hook
  (prog-mode . rainbow-mode))
#+end_src

*** Formatter (reformatter.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Formatter_(reformatter.el)-c873c6b6
:END:

=reformatter.el= (created by Purcell) lets you easily define an idiomatic command
to reformat the current buffer using a command-line program, together with an
optional minor mode which can apply this command automatically on save.

#+begin_src emacs-lisp
(use-package reformatter
  :init
  (defun ale-format-buffer ()
    (interactive)
    (let* ((mode-name (string-remove-suffix "-mode" (format "%s" major-mode)))
           (func-name (intern (format "%s-format-buffer" mode-name))))
      (if (functionp func-name)
          (funcall func-name)
        (user-error
         (format
          "No available formatter for %s. Use `reformatter-define' to create it."
          major-mode)))))
  :config
  (reformatter-define lua-format
    :program "stylua"
    :args '("--indent-width" "2" "-")
    :lighter " styLua")
  (reformatter-define python-format
    :program "black"
    :args '("-")
    :lighter " blackFMT")
  :bind
  (:map ale-apps-map
        ("f" . ale-format-buffer)))
#+end_src

*** Indent lines (highlight-indent-guides.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Indent_lines_(highlight-indent-guides.el)-df3d281e
:END:

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :hook
  (prog-mode . (lambda ()
                 (unless (eq major-mode 'js-mode)
                   (highlight-indent-guides-mode))))
  :config
  (setq highlight-indent-guides-method 'bitmap)
  (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line)
  (setq highlight-indent-guides-responsive 'stack)
  (setq highlight-indent-guides-delay 0)
  (setq highlight-indent-guides-suppress-auto-error t)
  (setq highlight-indent-guides-auto-stack-odd-face-perc 15)
  (setq highlight-indent-guides-auto-stack-even-face-perc 25)
  (setq highlight-indent-guides-auto-stack-character-face-perc 35))
#+end_src

*** Syntax checker (flycheck.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Syntax_checker_(flycheck.el)-932c904f
:END:

#+begin_src emacs-lisp
(use-package flycheck
  :after-call prog-mode-hook
  :config
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (global-flycheck-mode)
  (setq-default flycheck-emacs-lisp-load-path 'inherit)
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers '(javascript-jshint json-jsonlist))))
#+end_src

*** REST client (restclient.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-REST_client_(restclient.el)-cd7d4301
:END:

#+begin_src emacs-lisp
(use-package restclient)
#+end_src

*** Scratch buffers (scratch.el)
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Scratch_buffers_(scratch.el)-c4698d0e
:END:

=ale/scratch= will produce a org-mode buffer with right header-args for current
jupyter kernel.  Use it with =SPC f s=, doing it with a prefix argument (=C-u=) will
prompt for a major mode instead.  Simple yet super effective!

**** Autoload
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Scratch_buffers_(scratch.el)-Autoload-7b83f99a
:END:

#+begin_src emacs-lisp :tangle (ale-init-ext-tangle)
;;; ale-scratch.el --- -*- lexical-binding: t -*-

(defun ale-scratch--list-modes ()
  "List known major modes."
  (cl-loop for sym the symbols of obarray
           for name = (symbol-name sym)
           when (and (functionp sym)
                     (not (member sym minor-mode-list))
                     (string-match "-mode$" name)
                     (not (string-match "--" name)))
           collect (substring name 0 -5)))

;;;###autoload
(defun ale/scratch (query-for-mode)
  "Create or switch to an org-mode scratch buffer with jupyter session configured.
If called with prefix arg, prompt for a major mode for the buffer."
  (interactive "P")
  (let ((buf (get-buffer "*ALE-scratch*")))
    (unless buf
      (let* ((new-buf (generate-new-buffer "*ALE-scratch*"))
             (jpt-session (or (bound-and-true-p conda-env-current-name) "base"))
             (text (concat "#+PROPERTY: header-args:python :session " jpt-session))
             (mode "org"))
        (with-current-buffer new-buf
          (when query-for-mode
            (setq mode (completing-read "Mode: " (ale-scratch--list-modes) nil t nil nil))
            (setq text (format "Scratch buffer for: %s" mode)))
          (insert text)
          (funcall (intern (concat mode "-mode")))
          (setq-local org-image-actual-width '(1024))
          (unless (string= mode "org") (comment-region (point-min) (point-max)))
          (insert "\n\n")
          (setq buf new-buf))))
    (pop-to-buffer buf)))
#+end_src

**** Config
:PROPERTIES:
:CUSTOM_ID: Programming-DevTools-Scratch_buffers_(scratch.el)-Config-0f0fb1cb
:END:

#+begin_src emacs-lisp
(bind-keys
 :map ale-apps-map
 ("s" . ale/scratch))
#+end_src
